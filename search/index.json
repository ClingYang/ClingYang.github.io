[{"content":"关于主任务函数 之前写到在主函数里面处理的事件也不知道有没有问题 之所以这么写是因为我觉得如果全用cubemax配置好的话下次如果换主控可能会比较麻烦 所以今天再细看一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void AppTaskCreate(void) { taskENTER_CRITICAL(); // 进入临界区 BaseType_t xReturn = pdPASS; /* 定义一个创建信息返回值，默认为pdPASS */ uint32_t count = 0; /* 创建Test_Task任务 */ xReturn = xTaskCreate((TaskFunction_t)color_led_task_fun, /* 任务入口函数 */ (const char *)\u0026#34;COLOR_LED_TASK\u0026#34;, /* 任务名字 */ (uint16_t)256, /* 任务栈大小 */ (void *)NULL, /* 任务入口函数参数 */ (UBaseType_t)osPriorityNormal, /* 任务的优先级 */ (TaskHandle_t *)\u0026amp;COLOR_LED_Handle); /* 任务控制块指针 */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;COLOR_LED_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); /* 运行占用 */ memset(pcWriteBuffer, 0, 400); vTaskList(pcWriteBuffer); // 获取内存信息 UART1_Printf(\u0026#34;\\r\\n\u0026#34;); UART1_Printf(\u0026#34;%s\\n\\r\u0026#34;, pcWriteBuffer); memset(pcWriteBuffer, 0, 400); vTaskGetRunTimeStats(pcWriteBuffer); // 获取CPU占用率信息 UART1_Printf(\u0026#34;\\r\\n\u0026#34;); UART1_Printf(\u0026#34;%s\\n\\r\u0026#34;, pcWriteBuffer); return; error: UART1_Printf(\u0026#34;App_Task_Create[error]:Task Create fail,system exception\\n\u0026#34;); while (1) { UART1_Printf(\u0026#34;error count:%d\\n\u0026#34;, (int)count++); app_main_delay_ms(1000); } taskEXIT_CRITICAL(); // 退出临界区 } 又添加了一些功能\n串口就会打印出这样的内容 当然在这之前还是要在cubemax里面打开一些东西 参考链接 全部打开变成Enable 每次配置任务就可以这样进行 修改如下 当然应用函数还是得要你自己写的 这样好处我感觉就是到时候你要是迁移芯片修改的应该不是很大\n","date":"2025-03-20T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320144944405.png","permalink":"https://clingyang.github.io/p/hal_freertos%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%952/","title":"HAL_Freertos的使用记录2"},{"content":"为了保存工作状态 长按关机后或者30分钟后断电 在这个操作前先保存状态 下次开机时直接读取保存内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026#34;Flash_baup.h\u0026#34; void SaveStateToFlash(uint8_t level, uint8_t reverse) { // 解锁 Flash HAL_FLASH_Unlock(); // 擦除 Flash 页 FLASH_EraseInitTypeDef EraseInitStruct; uint32_t PageError = 0; EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; EraseInitStruct.PageAddress = FLASH_USER_START_ADDR; EraseInitStruct.NbPages = 1; if (HAL_FLASHEx_Erase(\u0026amp;EraseInitStruct, \u0026amp;PageError) != HAL_OK) { // 错误处理 Error_Handler(); } // 写入当前档位和正反转状态 uint32_t data = (level \u0026lt;\u0026lt; 8) | reverse; if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, FLASH_USER_START_ADDR, data) != HAL_OK) { // 错误处理 Error_Handler(); } // 锁定 Flash HAL_FLASH_Lock(); } void LoadStateFromFlash(uint8_t *level, uint8_t *reverse) { uint32_t data = *(__IO uint32_t*)FLASH_USER_START_ADDR; *level = (data \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; *reverse = data \u0026amp; 0xFF; } 头文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #ifndef FLASH_BAUP_H #define FLASH_BAUP_H #include \u0026#34;stm32f0xx_hal.h\u0026#34; #include \u0026#34;main.h\u0026#34; // 定义 Flash 存储地址 #define FLASH_USER_START_ADDR ((uint32_t)0x08007000) /* Start @ of user Flash area, assuming 1KB per page and 128KB total Flash size */ // Flash 操作函数声明 void SaveStateToFlash(uint8_t level, uint8_t reverse); void LoadStateFromFlash(uint8_t *level, uint8_t *reverse); #endif // FLASH_BAUP_H 保存的是两个 uint8_t 的数据 值得注意的是我们要注意地址 存储的起始地址有讲究的 最后通过keil 也是能看到的 如果资源紧张 可以debug 一下 ","date":"2025-03-20T11:46:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145049973.png","permalink":"https://clingyang.github.io/p/hal_flash-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%AF%BB%E5%8F%96/","title":"HAL_flash 数据备份与读取"},{"content":"最近入了一个ESP32 兄弟们，这玩意还可以，买来肯定是给它点亮啊对吧 我就是点灯侠🎇 😭千万不要不接天线啊，不然你会一直找不到你的wifi 1.点灯第一步你得有IDE == Arduino 就是这个绿东西\n可是怎么下载安装呢？自己百度吧，当然你要是懒这边也给您附加了连接\nArduino 安装 \u0026mdash;这里作者认为你看连接并且你安装好了\n2023/5/2 值得注意的是 这个sdk你需要以管理员的身份去运行\nok 现在进入第二步\n2.编写点灯程序 1 2 3 4 5 6 7 8 9 10 11 12 13 const int LED = 2; void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } 烧录 一定要选串口\n上传 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 项目使用了 219045 字节，占用了 (16%) 程序存储空间。最大为 1310720 字节。 全局变量使用了16088字节，(4%)的动态内存，余留311592字节局部变量。最大为327680字节。 esptool.py v3.3 Serial port COM4 Connecting...... Chip is ESP32-D0WD-V3 (revision 3) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: e8:31:cd:74:1c:84 Uploading stub... Running stub... Stub running... Changing baud rate to 921600 Changed. Configuring flash size... Flash will be erased from 0x00001000 to 0x00005fff... Flash will be erased from 0x00008000 to 0x00008fff... Flash will be erased from 0x0000e000 to 0x0000ffff... Flash will be erased from 0x00010000 to 0x00045fff... Flash params set to 0x022f Compressed 18880 bytes to 12992... Writing at 0x00001000... (100 %) Wrote 18880 bytes (12992 compressed) at 0x00001000 in 0.5 seconds (effective 279.9 kbit/s)... Hash of data verified. Compressed 3072 bytes to 128... Writing at 0x00008000... (100 %) Wrote 3072 bytes (128 compressed) at 0x00008000 in 0.1 seconds (effective 350.9 kbit/s)... Hash of data verified. Compressed 8192 bytes to 47... Writing at 0x0000e000... (100 %) Wrote 8192 bytes (47 compressed) at 0x0000e000 in 0.1 seconds (effective 490.3 kbit/s)... Hash of data verified. Compressed 219440 bytes to 120828... Writing at 0x00010000... (12 %) Writing at 0x0001d956... (25 %) Writing at 0x00022fd3... (37 %) Writing at 0x00028288... (50 %) Writing at 0x0002d6ef... (62 %) Writing at 0x00035f5d... (75 %) Writing at 0x0003e042... (87 %) Writing at 0x000438e3... (100 %) Wrote 219440 bytes (120828 compressed) at 0x00010000 in 2.4 seconds (effective 722.3 kbit/s)... Hash of data verified 烧写成功看你的板子是不是在blink blink ✨✨✨✨点灯视频 ","date":"2025-03-20T11:08:09+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145935000.png","permalink":"https://clingyang.github.io/p/esp32-arduino-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"ESP32 ARDUINO 开发环境搭建"},{"content":"文章默认格式模版 推荐在模板中设置，修改 archetypes/default.md（如果没有则新建一个即可）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- date : \u0026#39;{{ .Date }}\u0026#39; draft: true title: \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; image: https://picsum.photos/800/600.webp?random={{ substr (md5 (.Date)) 4 8 }} description: 描述 summary: 文章摘要，重要！关乎ESO搜索引擎优化 categories: [ \u0026#34;hugo\u0026#34;, \u0026#34;笔记\u0026#34;, ] tags: [ \u0026#34;hugo\u0026#34;, \u0026#34;笔记\u0026#34; ] --- 这里的重点是 image 这一行，即使用了 Lorem Picsum 的接口，然后就可以得到一张随机的图片，更多详情也可前往 Lorem Picsum 了解。 之后，我们通过 hugo new 命令时，新建的文章会随机匹配一张图片\n文章的一写变量的写法 说明tags 一般是在文章内部的标题 我还要修改图片粘贴路径 在vscode 设置里面 评论区我成了 参考链接 效果可以看我评论区\n1 2 3 4 #创建新的笔记是 .\\hugo new content post/Blogname/index.md # 本地调试启动服务 .\\hugo server -D 文章图片 操作 【Hugo】markdown中图片大小和对齐方式调整\n脚本自动化 在vscode 我建立了一个工作区 写了一些个脚本 新建文章 删除文章 本地预览 更新远程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 { \u0026#34;folders\u0026#34;: [ { \u0026#34;path\u0026#34;: \u0026#34;..\u0026#34; } ], \u0026#34;settings\u0026#34;: { \u0026#34;VsCodeTaskButtons.tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;$(zap)New\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;New\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;创建一个新文章\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;$(notebook-delete-cell) Clean\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;clean\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;删除指定文章\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;$(globe)localview\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;localview\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;本地预览\u0026#34; }, ] }, \u0026#34;tasks\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;New\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;./hugo.exe new content post/${input:Blogname}/index.md\u0026#34;, }, { \u0026#34;label\u0026#34;: \u0026#34;clean\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;Remove-Item -Recurse -Force -Path ${workspaceFolder}\\\\content\\\\post\\\\${input:cleanBlogname}\u0026#34;, }, { \u0026#34;label\u0026#34;: \u0026#34;localview\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;./hugo.exe server -D\u0026#34;, }, ], \u0026#34;inputs\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Blogname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;输入文章名字\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;Blogname\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;cleanBlogname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;输入需要删除文章名字\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;cleanBlogname\u0026#34; }, ] } } 在 VSCode 的 tasks.json 文件中，$(zap) 是一个图标名称，用于在任务列表中显示一个图标。这些图标名称是 VSCode 的内置图标，用于在用户界面中提供视觉提示。\nVSCode 的图标名称是基于 Octicons 图标集的。Octicons 是 GitHub 的官方图标集，广泛用于 VSCode 的界面中。以下是一些常用的图标名称示例：\n$(zap) - 闪电图标，通常用于表示快速或强大的操作. $(gear) - 齿轮图标，通常用于设置或配置相关的操作. $(file) - 文件图标，用于表示文件相关的操作. $(trash) - 垃圾桶图标，用于表示删除或清理相关的操作. 你可以在 VSCode 的任务配置中使用这些图标名称来为任务添加视觉效果，使任务列表更加直观和易于理解.\n如果你需要查找更多的图标名称，可以参考 Octicons 的官方文档，其中列出了所有可用的图标及其名称.\n外链图片图床 不搞感觉会炸\n参考链接1\n参考链接2 参考连接3\n1 2 3 4 如果加速源无法使用可以更改加速源，将github的设定自定义域名处的cdn.jsdmirror.com改为其他加速源 jsd.onmicrosoft.cn gcore.jsdelivr.net testingcf.jsdelivr.net 下面这张图是图床上的 还有一些链接建立网站时候用的 https://www.hughh.top/posts/hugo-guide/\n","date":"2025-02-18T11:13:00+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145323127.png","permalink":"https://clingyang.github.io/p/hugo%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E%E8%AE%B0%E8%BD%BD%E7%AC%94%E8%AE%B0/","title":"hugo格式说明记载笔记"},{"content":"环境搭建 环境搭建后第一段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; void taskA(void *pvParameter) { while (1) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Task 1\u0026#34;); vTaskDelay(pdMS_TO_TICKS(500)); } } void app_main(void) { // tskNO_AFFINITY 双核都可以运行 xTaskCreatePinnedToCore(taskA, \u0026#34;taskA\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); } main 是特殊的组件\n任务同步 队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;freertos/queue.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; QueueHandle_t Queue_handle = NULL; typedef struct { int a; int b; } QueueMessage_t; void taksA(void *pvParameter) { QueueMessage_t message; message.a = 1; message.b = 2; while (1) { if (xQueueSend(Queue_handle, \u0026amp;message, 0) == pdTRUE) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Send success\u0026#34;); } else { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Send failed\u0026#34;); } message.a++; message.b++; vTaskDelay(pdMS_TO_TICKS(500)); } } void taksB(void *pvParameter) { QueueMessage_t message; while (1) { if (pdTRUE == xQueueReceive(Queue_handle, \u0026amp;message, 0)) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Receive success\u0026#34;); ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;a=%d, b=%d\u0026#34;, message.a, message.b); } else { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Receive failed\u0026#34;); } vTaskDelay(pdMS_TO_TICKS(500)); } } void app_main(void) { Queue_handle = xQueueCreate(10, sizeof(QueueMessage_t)); if (NULL == Queue_handle ) { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Queue create failed\u0026#34;); } else { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Queue create success\u0026#34;); } xTaskCreatePinnedToCore(taksA, \u0026#34;taksA\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); xTaskCreatePinnedToCore(taksB, \u0026#34;taksB\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); } 信号量 任务保护硬件机制 事件组 直达任务通知 原生区别 GPIO 操作 环境搭建 乐鑫官方文章 text text ","date":"2025-01-08T23:58:10+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145836481.png","permalink":"https://clingyang.github.io/p/esp_note/","title":"ESP_Note"},{"content":"前言 我们有些程序在执行或者和下位几交互的过程中可能会出现下位机硬性规定需要等待多少秒的情况然而我们的程序又必须得执行下去这样会造成单片机大量资源出现过度浪费的情况解决这种问题的办法有很多。\n分享一种思路 1.创建一个ms(毫秒)级延时中断 2.创建计数的变量 3.在需要延时的函数中对变量阈值进行判断 4.验证实例\u0026ndash;完整使用记录代码\nCubemax创建一个ms定时器很简单这里不赘述附上参考链接：\nSTM32CubeMX学习笔记（5）——基本定时器接口使用\nuint32_t time = 0;\nextern uint32_t time;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if(htim-\u0026gt;Instance == TIM7) // 定时器6基地址 { ​ // 自定义应用程序 ​ time++; // 每1ms进来1次 } } 业务逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ ​ if(time == 1000) // 每1秒LED灯翻转一次 ​ { ​ HAL_GPIO_TogglePin(LED_G_GPIO_Port,LED_G_Pin); ​ time = 0; ​ } } 这样就能做到每秒触发一次少占用资源了\n问题 if(time == 1000)\n这里我们是让它到达1000ms时 就触发业务函数 如若单业务逻辑比较多时\n此时到达1000ms 时 if 来不及判断 那么 这个函数永远没有执行 那么 这种情况如何处理 ？\n如果是换成if(time \u0026gt;= 1000)\n又那么超过了多少个ms呢？\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321152335834.png","permalink":"https://clingyang.github.io/p/hal_cubemx%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"HAL_Cubemx定时器使用记录"},{"content":" 面对无规律长度的数据帧如何处理？ 不定长数据接收可以使用每帧数据发送完成后会有一定的空闲时间\u0026quot;帧的时间间隔?\u0026quot; 如果你想每帧都要可以采用dma加空闲中断的方式空闲中断一次就是一帧数据接受完成再去做其它数据解析和其他业务出来不过需要我们注意的是这里面有个小坑 __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1);\n我先说下如何处理： 1 2 3 4 5 6 7 8 9 10 11 if (__HAL_UART_GET_FLAG(\u0026amp;huart1,UART_FLAG_IDLE)== SET) { uint16_t temp = 0; __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1); HAL_UART_DMAStop(\u0026amp;huart1); temp = huart1.Instance-\u0026gt;SR; temp = huart1.Instance-\u0026gt;DR; temp = hdma_usart1_rx.Instance-\u0026gt;CNDTR; Usart1type.UsartDMARecLen = USART1_DMA_REC_SIE - temp; HAL_UART_RxCpltCallback(\u0026amp;huart1); } 这个函数网上说什么有bug还是啥 temp = huart1.Instance-\u0026gt;SR;\ntemp = huart1.Instance-\u0026gt;DR;\n还要读一下这两寄存器\n原理很简单就是打开空闲中断函数\n触发中断后dma接收\n接收完后搬到接收数组里面清除dma数组\n做业务逻辑处理 处理完就全部数组清除\n操作步骤如下： 1.开启中断函数\n1 2 3 4 5 6 7 8 9 10 11 void EnableUsart_IT(void){ __HAL_UART_ENABLE_IT(\u0026amp;huart1,UART_IT_RXNE); __HAL_UART_ENABLE_IT(\u0026amp;huart1,UART_IT_IDLE); __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1); HAL_UART_Receive_DMA(\u0026amp;huart1,Usart1type.Usart1DMARecBuffer,USART1_DMA_REC_SIE); } 2.触发中断后dma接收\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 void USART1_IRQHandler(void) { /* USER CODE BEGIN USART1_IRQn 0 */ if (__HAL_UART_GET_FLAG(\u0026amp;huart1,UART_FLAG_IDLE)== SET) { uint16_t temp = 0; __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1); HAL_UART_DMAStop(\u0026amp;huart1); temp = huart1.Instance-\u0026gt;SR; temp = huart1.Instance-\u0026gt;DR; temp = hdma_usart1_rx.Instance-\u0026gt;CNDTR; Usart1type.UsartDMARecLen = USART1_DMA_REC_SIE - temp; HAL_UART_RxCpltCallback(\u0026amp;huart1); } /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler(\u0026amp;huart1); /* USER CODE BEGIN USART1_IRQn 1 */ HAL_UART_Receive_DMA(\u0026amp;huart1,Usart1type.Usart1DMARecBuffer,USART1_DMA_REC_SIE); //再次打开DMA接收 /* USER CODE END USART1_IRQn 1 */ } 3.接收完后搬到接收数组里面清除dma数组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* USER CODE BEGIN 1 */ void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){ if (huart-\u0026gt;Instance==USART1) { memcpy(\u0026amp;Usart1type.Usart1RecBuffer[Usart1type.UsartRecLen],Usart1type.Usart1DMARecBuffer,Usart1type.UsartDMARecLen); Usart1type.UsartRecLen=Usart1type.UsartDMARecLen; memset(Usart1type.Usart1DMARecBuffer,0x00,sizeof(Usart1type.Usart1DMARecBuffer)); Usart1type.UsartRecFlag=1; } } 4.业务逻辑处理\n我就简单的串口打印测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { if (Usart1type.UsartRecFlag==1 ) { ​ printf(\u0026#34;re:%s,len%d\\r\\n\u0026#34;,Usart1type.Usart1RecBuffer,Usart1type.UsartDMARecLen); ​ memset(Usart1type.Usart1RecBuffer,0x00,sizeof(Usart1type.Usart1RecBuffer)); ​ Usart1type.UsartRecFlag=0; ​ Usart1type.UsartRecLen=0; } /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } 参考代码：就一积分 给我点\n串口空闲中断cubemax任意长度数据资源-CSDN文库 ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321093939084.png","permalink":"https://clingyang.github.io/p/hal_dma%E4%B8%AD%E6%96%AD%E7%A9%BA%E9%97%B2%E6%8E%A5%E5%8F%97%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE1/","title":"HAL_DMA中断空闲接受不定长数据1"},{"content":"空闲中断 + dma 上次那篇文章确实没有好好使用好HAL库 现在 重新再来写一个 这个是DMA 收发 只需要在cubmax里面打开DMA设置 和 中断 就行 然后就是代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 extern UART_HandleTypeDef huart1; void test_task_fun(void *arg){ const char t_data[]={\u0026#34;-----------\\n\u0026#34;}; char tbuf[128]; char rbuf[128]; memset(tbuf,0,sizeof(tbuf)); memset(rbuf,0,sizeof(rbuf)); __HAL_UART_ENABLE_IT(\u0026amp;huart1,UART_IT_IDLE); HAL_UART_Transmit_DMA(\u0026amp;huart1, (uint8_t*)t_data, strlen(t_data)); /* Infinite loop */ for(;;) { if(HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rbuf, sizeof(rbuf)-1)==HAL_OK)\t{ memcpy(tbuf,rbuf,sizeof(rbuf)); HAL_UART_Transmit_DMA(\u0026amp;huart1, (uint8_t*)tbuf, strlen(tbuf)); }\tosDelay(1); } } ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321093939084.png","permalink":"https://clingyang.github.io/p/hal_dma%E4%B8%AD%E6%96%AD%E7%A9%BA%E9%97%B2%E6%8E%A5%E5%8F%97%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE2/","title":"HAL_DMA中断空闲接受不定长数据2"},{"content":"旨在于多串口使用printf 重定义 myprintf.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026#34;myprintf.h\u0026#34; #include \u0026#34;stm32f1xx_hal.h\u0026#34; #include \u0026lt;stdarg.h\u0026gt; // va_list va_start va_end #include \u0026lt;stdio.h\u0026gt; // sprintf #include \u0026lt;string.h\u0026gt; // strlen extern UART_HandleTypeDef huart1; void UART1_Printf(const char* fmt, ...) { char buff[64]; va_list args; va_start(args, fmt); vsnprintf(buff, sizeof(buff), fmt, args); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)buff, strlen(buff), HAL_MAX_DELAY); va_end(args); } myprintf.h 1 2 3 4 5 6 7 8 9 10 11 12 #ifndef __MYPRINTF_H_ #define __MYPRINTF_H_ #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif void UART1_Printf(const char* fmt, ...); #ifdef __cplusplus } #endif #endif ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321093232384.png","permalink":"https://clingyang.github.io/p/hal_printf-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/","title":"HAL_Printf 自定义多个串口打印"},{"content":"引言 HAL_PWM配置占空比频率 讲解占空比频率 配置占空比频率 定时器 之间的关系以及参数配置\n参考连接 1.STM32CubeMX学习笔记（13）——PWM输出(呼吸灯)使用 2.STM32标准库+HAL库 | 高精度动态调节PWM输出频率+占空比\n看你cubemx 里面的配置时钟频率是多少 参照第二篇文章描述修改 下面俩个参数就行 uint16_t prescaler\nuint64_t tim_clk_freq\n实战操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void set_pwm_param(TIM_HandleTypeDef htim, uint32_t Channel, uint32_t freq, uint16_t duty) { uint16_t prescaler = 72-1; uint64_t tim_clk_freq = 72000000; //计算PWM频率，所对应的自动重装载 ---\u0026gt; ARR = 主频 / (预分�?+1) / 预期PWM频率(Hz) - 1 float pwm_freq_arr = (tim_clk_freq * 1.0) / (prescaler+1) / freq * 1.0 - 1; //计算PWM占空比，对应比较寄存器的 ---\u0026gt; CCR = 预期占空�? * (自动重装载�??+1) //占空比则由捕/比较寄存器（TIMx_CRx）寄存器决定。占空比:duty = Pluse / (ARR+1) float pwm_duty_pulse = duty * 1.0 / 100 * (pwm_freq_arr + 1); //配置PSC预分频 __HAL_TIM_SET_PRESCALER(\u0026amp;htim, prescaler); //配置PWM频率 ARR __HAL_TIM_SetAutoreload(\u0026amp;htim, (uint16_t)pwm_freq_arr); //配置PWM占空比 __HAL_TIM_SetCompare(\u0026amp;htim, Channel, (uint16_t)pwm_duty_pulse); // printf(\u0026#34;pwm_freq_arr:%.2f\\r\\n\u0026#34;, pwm_freq_arr); // printf(\u0026#34;pwm_duty_pulse:%.2f\\r\\n\u0026#34;, pwm_duty_pulse); } ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321150515154.png","permalink":"https://clingyang.github.io/p/hal_pwm%E9%85%8D%E7%BD%AE%E5%8D%A0%E7%A9%BA%E6%AF%94%E9%A2%91%E7%8E%87/","title":"HAL_PWM配置占空比频率"},{"content":"控制pwm开关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //启动定时器 HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim); //关闭定时器 HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim); //启动指定通道PWM HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel); //停止指定通道PWM HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel); //设置指定通道占空比 void __HAL_TIM_SetCompare(TIM_HandleTypeDef *htim, uint32_t Channel,uint16_t Value); //设置定时器计数器值 coid __HAL_TIM_SetCompare(TIM_HandleTypeDef *htim, uint16_t Value) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if (sta==0){ HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); } else if(sta==1){ // D=5% HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); D=5; HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); } else if (sta==2){ // 10%≤D≤85% HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); D=50; HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); } else if (sta==3){ // 85%\u0026lt;D≤90% HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); D=88;HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); /// 这里的Start 已经不起作用了 } ** HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2);\n相当于把这个中断使能关闭了需要到外部开启 ** 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 / 按键中断 void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin==SW1_Pin) { HAL_GPIO_WritePin(GPIOB, LED_G_Pin|LED_B_Pin|LED_R_Pin, GPIO_PIN_SET); HAL_GPIO_TogglePin(LED_G_GPIO_Port,LED_G_Pin); HAL_UART_Transmit(\u0026amp;huart1,\u0026#34;G\u0026#34;, sizeof(\u0026#34;G\u0026#34;)-1, 100); sta--; if(sta==4){ HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); } } else if (GPIO_Pin==SW3_Pin){ HAL_GPIO_WritePin(GPIOB, LED_G_Pin|LED_B_Pin|LED_R_Pin, GPIO_PIN_SET); HAL_GPIO_TogglePin(LED_R_GPIO_Port,LED_R_Pin); HAL_UART_Transmit(\u0026amp;huart1,\u0026#34;R\u0026#34;, sizeof(\u0026#34;R\u0026#34;)-1, 100); sta++; if(sta==4){ HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); } } } void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if(sta==1){ set_pwm_param(htim2, TIM_CHANNEL_2, 1000, 50); } else if(sta==2) { set_pwm_param(htim2, TIM_CHANNEL_2, 1000, 20); } else if(sta==3){ // HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); HAL_UART_Transmit(\u0026amp;huart1,\u0026#34;3\u0026#34;, sizeof(\u0026#34;3\u0026#34;)-1, 100); } else if(sta==4){ // set_pwm_param(htim2, TIM_CHANNEL_2, 1000, 40); } } 大概就是这么个意思也没仔细看HAL开发的文档 就虾摸我豆\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321152821082.png","permalink":"https://clingyang.github.io/p/hal_pwm%E9%85%8D%E7%BD%AE%E5%8D%A0%E7%A9%BA%E6%AF%94%E9%A2%91%E7%8E%872%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E6%80%9D%E8%B7%AF/","title":"HAL_PWM配置占空比频率2按键控制思路"},{"content":" MultiButton 是一个开源的轻量的按键判断的函数 如下使该函数的开源链接：\n0x1abin/MultiButton: Button driver for embedded system (github.com)\n如何使用这个库里面已经是写的很清楚了\n事件 说明 PRESS_DOWN 按键按下，每次按下都触发 PRESS_UP 按键弹起，每次松开都触发 PRESS_REPEAT 重复按下触发，变量repeat计数连击次数 SINGLE_CLICK 单击按键事件 DOUBLE_CLICK 双击按键事件 LONG_PRESS_START 达到长按时间阈值时触发一次 LONG_PRESS_HOLD 长按期间一直触发 本人自己再封装了一遍两个按键\nbutton.c文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026#34;button.h\u0026#34; enum Button_IDs { start_key, Estop_key, }; struct Button btn1; struct Button btn2; static void BTN1_PRESS_DOWN_Handler(void *btn) { printf(\u0026#34;BTN1_PRESS_DOWN_Handler\\r\\n\u0026#34;); } static void BTN2_PRESS_DOWN_Handler(void *btn) { printf(\u0026#34;BTN2_PRESS_DOWN_Handler\\r\\n\u0026#34;); } static uint8_t read_button_GPIO(uint8_t button_id) { // you can share the GPIO read function with multiple Buttons switch (button_id) { case start_key: return HAL_GPIO_ReadPin(start_GPIO_Port, start_Pin); case Estop_key: return HAL_GPIO_ReadPin(Estop_GPIO_Port, Estop_Pin); default: return 0; } } // 按键注册 void button_register() { // 按键初始化 button_init(\u0026amp;btn1, read_button_GPIO, 0, start_key); button_init(\u0026amp;btn2, read_button_GPIO, 0, Estop_key); // 绑定到回调函数 button_attach(\u0026amp;btn1, SINGLE_CLICK, BTN1_PRESS_DOWN_Handler); button_attach(\u0026amp;btn2, SINGLE_CLICK, BTN2_PRESS_DOWN_Handler); button_start(\u0026amp;btn1); button_start(\u0026amp;btn2); } button.h文件 1 2 3 4 5 6 7 8 9 10 #ifndef __BUTTON_H_ #define __BUTTON_H_ #include \u0026#34;global.h\u0026#34; #include \u0026#34;multi_button.h\u0026#34; void button_register(); #endif 值得注意的是注意源函数里面有个类似“心跳“的东西 1 void button_ticks(void); 你得5ms执行一下 可以放while主循环里面\n1 2 3 4 5 while (1) { button_ticks(); HAL_Delay(5); } 也可以放在定时器中断里面\n1 2 3 4 5 6 7 8 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { //5ms if (htim-\u0026gt;Instance == TIM7) // { button_ticks(); } } 还有一点就是需要再执行主函数之前把按键注册什么函数初始化一遍\n1 button_init(\u0026amp;btn1, read_button_GPIO, 0, start_key); 第三个参数是按键高电平还是低电平有效\n多个按键的话 推荐使用下面的方式 把回调判断放在一个函数里面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026#34;multi_button.h\u0026#34; #include \u0026#34;bsp_key.h\u0026#34; #include \u0026#34;My_button.h\u0026#34; enum Button_IDs { btn1_id, btn2_id, BUTTONS_NUM, }; struct Button btn1; struct Button btn2; static uint8_t read_button_GPIO(uint8_t button_id) { switch (button_id) { case btn1_id: return HAL_GPIO_ReadPin(Key1_GPIO_PORT, Key1_GPIO_PIN); case btn2_id: return HAL_GPIO_ReadPin(Key2_GPIO_PORT, Key2_GPIO_PIN); default: return 0; } } static void Buttons_Callback(void *button) { PressEvent btn_event_val; btn_event_val = get_button_event((struct Button *)button); // FAN_DW 按键 触发事件处理 if ((struct Button *)button == \u0026amp;btn1) { if (btn_event_val == SINGLE_CLICK) { } } // UV_KEY 按键 触发事件 else if ((struct Button *)button == \u0026amp;btn2) { if (btn_event_val == SINGLE_CLICK) { } } } void My_button_init_attach_start(void) { button_init(\u0026amp;btn1, read_button_GPIO, 0, btn1_id); button_init(\u0026amp;btn2, read_button_GPIO, 0, btn2_id); button_attach(\u0026amp;btn1, SINGLE_CLICK, Buttons_Callback); button_attach(\u0026amp;btn1, LONG_PRESS_HOLD, Buttons_Callback); button_attach(\u0026amp;btn2, SINGLE_CLICK, Buttons_Callback); button_attach(\u0026amp;btn2, LONG_PRESS_HOLD, Buttons_Callback); button_start(\u0026amp;btn1); button_start(\u0026amp;btn2); } ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321151134842.png","permalink":"https://clingyang.github.io/p/hal_%E6%8C%89%E9%94%AE-multibutton%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"HAL_按键-MultiButton使用记录"},{"content":"下载链接： Automatic USB driver installer for FTDI and LibUSB drivers (visualgdb.com) 2. SEGGER - The Embedded Experts - Downloads - J-Link / J-Trace\n安装完成后 修改jlink的配置文件 然后修改你的下载器为jlink 烧录你的项目 绝对会出现下面的问题 那么打开下载的第一个软件 （点到这个jlink右键）如下操作： 修改后如下表示修改完成 下载成功的样子： 参考文章 解决openocd无法识别jlink的问题LIBUSB_ERROR_NOT_SUPPORTED_no emulators connected via usb-CSDN博客 OpenOCD-Jlink配置方法 ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321153322108.png","permalink":"https://clingyang.github.io/p/vscode_openocd_jlink-%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/","title":"VSCODE_openocd_Jlink 的配置笔记"},{"content":"1.准备工作 1.下载并安装VSCODE 在百度上搜索vscode记住一定要是官方的 不然你自己就是在给自己下毒2345全来了\n打红圈一定要有不然就是在垃圾网站上下的 VSCode下载链接\n选一个适合你的 安装正常流程走就行不再赘述 VScode安装\n2.安装开发插件 安装完成后配置一下开发环境 参考链接： VScode+EIDE调试STM32 推荐视频教程：\n不过本人和上面的配置有点出入\n我是安装完EIDE 和 Cortex-Debug 插件里面下载配置的环境：\n第一步： 按照如图的顺序安装配置环境 我用的是GCC的工具链其实也可以把keil的环境配置在里面这个网上也有好多教程大同小异 第二步： 创建示例工程\n上面有四种创建方式 我一般图简单 每次一个工程就用的是第四种 在github上拉取一个模板\n创建后打开工作区\n左上角有编译 清除 和 下载 我们先编译\n可以看见速度比keil 快很多 然后就可以下载测试一下了 这边需要根据自己的开发板选择led的引脚 我们的引脚是PC13 然后就是下载了下载之前我们把烧入工具换成openOCD\n然后下载就能看见现象了\n调试 Debug 这个操作就看下面的步骤了\n添加\n1 2 3 4 \u0026#34;liveWatch\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;samplesPerSecond\u0026#34;: 1 } 把要观察的变量加进去 刷新是1秒一次 最低了damn 然后启动就能看见变量变化了 刷新是1秒一次 最低了damn 然后启动就能看见变量变化了 ======================= #######2024620######### 这个debug 有个不好的点 就是每秒读一次 而却数组不能读多 比如buf[256]的话 你不能直接添加buff 去观察 你只要添加你想要观察的哪一个 buff[2] 或者其它\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321141258785.png","permalink":"https://clingyang.github.io/p/vscode%E5%BC%80%E5%8F%91stm32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"VScode开发stm32环境搭建"},{"content":"这次我们来实现用按键控制led 不带中断的方式 当然实例来源网络 加上自己整合 先熟悉流程 0.添加一个自己写的驱动库文件 为什么添加 笔者想的是一个项目工程希望能适应很多个应用场景需要什么直接在里面调用分装好的函数就行\n1.如何添加文件以及编写驱动后编译 用之前案例讲到的实例工程添加一个Hardware文件夹 ：\n1.封装LED库函数 Led.C 引脚按需配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026#34;stm32f10x.h\u0026#34; // Device header // LED 初始化 void LED_Init(void){ GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC,\u0026amp;GPIO_InitStruct); // 初始化 置1 GPIO_SetBits(GPIOC,GPIO_Pin_13); } void LED_ON(void){ GPIO_ResetBits(GPIOC,GPIO_Pin_13); } void LED_OFF(void){ GPIO_SetBits(GPIOC,GPIO_Pin_13); } // 高低电平反转 void LED_Turn(void) { if(GPIO_ReadOutputDataBit(GPIOC,GPIO_Pin_13)==0) { GPIO_SetBits(GPIOC,GPIO_Pin_13); } else { GPIO_ResetBits(GPIOC,GPIO_Pin_13); } } Led.h\n1 2 3 4 5 6 7 8 9 #ifndef __LED_H #define __LED_H void LED_Init(void); // led 引脚初始化 void LED_ON(void); // led 开 void LED_OFF(void); // led 关 void LED_Turn(void); // led 反转 #endif 2.封装Key函数库 和上步相同 Key.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; // 初始化接地按键 void Key_Init(void){ GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_12; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB,\u0026amp;GPIO_InitStruct); } uint8_t Key_GetNum(void){ uint8_t Key_Num = 0; if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)== 0){ Delay_ms(20); while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)== 0); Delay_ms(20); Key_Num = 1;\t} if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)== 0){ Delay_ms(20); while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)== 0); Delay_ms(20); Key_Num = 2; } return Key_Num; } key.h\n1 2 3 4 5 6 7 8 9 #ifndef __KEY_H #define __KEY_H void Key_Init(void); uint8_t Key_GetNum(void); #endif 编写功能需求 main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;LED.h\u0026#34; #include \u0026#34;Key.h\u0026#34; uint8_t KeyNum; uint8_t StaNum=0; int main(void) { LED_Init(); Key_Init(); while (1) { KeyNum = Key_GetNum(); if (KeyNum == 1) { LED_Turn(); } } } 现象就是按一下按键led pc13状态反转一次 编译下载看现象\n就是按一下按键led pc13状态反转一次\n编译下载看现象\n这里的项目配置不要出错\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321144847871.png","permalink":"https://clingyang.github.io/p/%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6led/","title":"按键控制led"},{"content":"所需代码 参考来源网络 延时函数参考：\nDelay.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026#34;stm32f10x.h\u0026#34; /** * @brief 微秒级延时 * @param xus 延时时长，范围：0~233015 * @retval 无 */ void Delay_us(uint32_t xus) { SysTick-\u0026gt;LOAD = 72 * xus;\t//设置定时器重装值 SysTick-\u0026gt;VAL = 0x00;\t//清空当前计数值 SysTick-\u0026gt;CTRL = 0x00000005;\t//设置时钟源为HCLK，启动定时器 while(!(SysTick-\u0026gt;CTRL \u0026amp; 0x00010000));\t//等待计数到0 SysTick-\u0026gt;CTRL = 0x00000004;\t//关闭定时器 } /** * @brief 毫秒级延时 * @param xms 延时时长，范围：0~4294967295 * @retval 无 */ void Delay_ms(uint32_t xms) { while(xms--) { Delay_us(1000); } } /** * @brief 秒级延时 * @param xs 延时时长，范围：0~4294967295 * @retval 无 */ void Delay_s(uint32_t xs) { while(xs--) { Delay_ms(1000); } } Delay.h 1 2 3 4 5 6 7 #ifndef __DELAY_H #define __DELAY_H void Delay_us(uint32_t us); void Delay_ms(uint32_t ms); void Delay_s(uint32_t s); #endif LED.c 用的PIN脚是PC13 可根据自己的情况修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026#34;stm32f10x.h\u0026#34; // Device header // LED 初始化 void LED_Init(void){ GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC,\u0026amp;GPIO_InitStruct); // 初始化置1 GPIO_SetBits(GPIOC,GPIO_Pin_13); } void LED1_ON(void){ GPIO_ResetBits(GPIOC,GPIO_Pin_13); } void LED1_OFF(void){ GPIO_SetBits(GPIOC,GPIO_Pin_13); } // 高低电平反转 void LED1_Turn(void) { if(GPIO_ReadOutputDataBit(GPIOC,GPIO_Pin_13)==0) { GPIO_SetBits(GPIOC,GPIO_Pin_13); } else { GPIO_ResetBits(GPIOC,GPIO_Pin_13); } } LED.h 1 2 3 4 5 6 7 8 9 #ifndef __LED_H #define __LED_H void LED_Init(void); // LED初始化 void LED1_ON(void); // void LED1_OFF(void); void LED1_Turn(void); #endif main.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;stm32f10x.h\u0026#34; #include \u0026#34;LED.h\u0026#34; #include \u0026#34;Delay.h\u0026#34; int main(void) { LED_Init(); // 初始LED while (1) { LED1_OFF(); Delay_ms(500); LED1_ON(); Delay_ms(500); } } 编译 下载 亮了 参考链接1：\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321144539906.png","permalink":"https://clingyang.github.io/p/%E7%82%B9%E4%BA%AE%E4%B8%80%E4%B8%AAled/","title":"点亮一个led"},{"content":"参考来源1 这是另一种方法\n在printf 重定向的基础上加上 一句\nsetbuf(stdout,NULL);\n参考来源2 自己写的笔记啦\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321140651747.png","permalink":"https://clingyang.github.io/p/%E5%85%B3%E4%BA%8Eclion%E5%BC%80%E5%8F%91stm32printf%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%96%B9%E6%B3%95/","title":"关于Clion开发stm32printf重定向问题简单解决问题方法"},{"content":" 主要利用的是vscode里面stm32forvscode的插件 第一步就是创建cubmax的工程 RCC 调试方式 和 时基 这里Debug 不整好 这个板子就会变砖 要用线刷了\n选择FREERTOS\n选择最大频率 .c 和 .h 文件分开生成 生成！！(原神启动) 关于这个框架的建立 我选择如下这样 应用和驱动：\n你新建了两个文件夹所以需要再makefile文件添加进来\n这个插件可以帮你添加但是需要你设置一下\nDrivers 层面 .c 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026#34;led_driver.h\u0026#34; /// @brief 全彩灯初始化 /// @param void led_init(void) { HAL_GPIO_WritePin(RGB_PORT_R, RGB_PIN_R, GPIO_PIN_SET); HAL_GPIO_WritePin(RGB_PORT_G, RGB_PIN_G, GPIO_PIN_SET); HAL_GPIO_WritePin(RGB_PORT_B, RGB_PIN_B, GPIO_PIN_SET); } /// @brief 设置灯的颜色 /// @param red /// @param green /// @param blue void color_led_set(uint8_t red, uint8_t green, uint8_t blue) { //红灯： HAL_GPIO_WritePin(RGB_PORT_R, RGB_PIN_R, (GPIO_PinState)!red); //绿灯： HAL_GPIO_WritePin(RGB_PORT_G, RGB_PIN_G, (GPIO_PinState)!green); //蓝灯： HAL_GPIO_WritePin(RGB_PORT_B, RGB_PIN_B, (GPIO_PinState)!blue); } .h文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #ifndef __LED_DRIVER_H__ #define __LED_DRIVER_H__ #include \u0026#34;main.h\u0026#34; #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif #define RGB_PORT_R GPIOB #define RGB_PORT_G GPIOB #define RGB_PORT_B GPIOB #define RGB_PIN_R GPIO_PIN_5 #define RGB_PIN_G GPIO_PIN_0 #define RGB_PIN_B GPIO_PIN_1 void color_led_set(uint8_t red, uint8_t green, uint8_t blue); void led_init(void); #ifdef __cplusplus } #endif #endif /* __LED_DRIVER_H__ */ app应用层面 .h 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #ifndef MAIN_INCLUDE_APPLICATION_H_ #define MAIN_INCLUDE_APPLICATION_H_ #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif /*Driver Include*/ #include \u0026#34;led_driver.h\u0026#34; #include \u0026#34;beep_driver.h\u0026#34; #include \u0026#34;my_printf.h\u0026#34; /*User lib Include*/ /*pnblic Include*/ #include \u0026#34;FreeRTOS.h\u0026#34; #include \u0026#34;task.h\u0026#34; #include \u0026#34;main.h\u0026#34; #include \u0026#34;cmsis_os.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; // sprintf #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; /********************************************************API********************************************************/ void AppTaskCreate(void); /*LED app*/ void color_led_task_fun(void *argument); /* 测试任务 */ void test_task_fun(void *arg); #ifdef __cplusplus } #endif #endif /* MAIN_INCLUDE_APPLICATION_H_ */ .c 创建任务函数文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include \u0026#34;Application.h\u0026#34; /**************************** 任务句柄 ********************************/ /* * 任务句柄是一个指针，用于指向一个任务，当任务创建好之后，它就具有了一个任务句柄 * 以后我们要想操作这个任务都需要通过这个任务句柄，如果是自身的任务操作自己，那么 * 这个句柄可以为NULL。 */ static TaskHandle_t COLOR_LED_Handle = NULL; /* LED任务句柄 */ static TaskHandle_t TEST_TASK_Handle = NULL; /* 任务句柄 */ /********************************** 内核对象句柄 *********************************/ /* * 信号量，消息队列，事件标志组，软件定时器这些都属于内核的对象，要想使用这些内核 * 对象，必须先创建，创建成功之后会返回一个相应的句柄。实际上就是一个指针，后续我 * 们就可以通过这个句柄操作这些内核对象。 * * 内核对象说白了就是一种全局的数据结构，通过这些数据结构我们可以实现任务间的通信， * 任务间的事件同步等各种功能。至于这些功能的实现我们是通过调用这些内核对象的函数 * 来完成的 * */ /******************************* 全局变量声明 ************************************/ /* * 当我们在写应用程序的时候，可能需要用到一些全局变量。 */ /* ************************************************************************* * 函数声明 ************************************************************************* */ void app_main_delay_ms(uint16_t ms); /* ************************************************************************* ************************************************************************* */ /// @brief 创建任务 /// @param void AppTaskCreate(void) { taskENTER_CRITICAL(); // 进入临界区 BaseType_t xReturn = pdPASS; /* 定义一个创建信息返回值，默认为pdPASS */ uint32_t count = 0; /* 创建Test_Task任务 */ xReturn = xTaskCreate((TaskFunction_t)color_led_task_fun, /* 任务入口函数 */ (const char *)\u0026#34;COLOR_LED_TASK\u0026#34;, /* 任务名字 */ (uint16_t)256, /* 任务栈大小 */ (void *)NULL, /* 任务入口函数参数 */ (UBaseType_t)osPriorityNormal, /* 任务的优先级 */ (TaskHandle_t *)\u0026amp;COLOR_LED_Handle); /* 任务控制块指针 */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;COLOR_LED_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); xReturn = xTaskCreate((TaskFunction_t)test_task_fun, /* 任务入口函数 */ (const char *)\u0026#34;TEST_TASK\u0026#34;, /* 任务名字 */ (uint16_t)256, /* 任务栈大小 */ (void *)NULL, /* 任务入口函数参数 */ (UBaseType_t)osPriorityNormal, /* 任务的优先级 */ (TaskHandle_t *)\u0026amp;TEST_TASK_Handle); /* 任务控制块指针 */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;TEST_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); return; error: UART1_Printf(\u0026#34;App_Task_Create[error]:Task Create fail,system exception\\n\u0026#34;); while (1) { UART1_Printf(\u0026#34;error count:%d\\n\u0026#34;, (int)count++); app_main_delay_ms(1000); } taskEXIT_CRITICAL(); // 退出临界区 } void app_main_delay_ms(uint16_t ms) { vTaskDelay(pdMS_TO_TICKS(ms)); } .c 任务分离文件\n关于如何应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026#34;Application.h\u0026#34; /// @brief color_led_task_fun RGB 灯的应用 /// @param arg void color_led_task_fun(void *arg) { while (true) { /* color_led的应用 */ //红灯亮： color_led_set(1, 0, 0); os_Delay(1000); //绿灯亮： color_led_set(0, 1, 0); os_Delay(1000); //蓝灯亮： color_led_set(0, 0, 1); os_Delay(1000); //黄灯亮： color_led_set(1, 1, 0); os_Delay(1000); //紫灯亮： color_led_set(1, 0, 1); os_Delay(1000); //粉灯亮 color_led_set(0, 1, 1); os_Delay(1000); } } 关于如何嵌入框架 你只需要以下两步就行 第二步 ","date":"2024-11-20T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320151456223.png","permalink":"https://clingyang.github.io/p/hal_freertos%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%951/","title":"HAL_Freertos的使用记录1"},{"content":"第一步准备环境 STM32CubeMX VSCODE MinGW OpenOcd arm-none-eabi-gcc 然后把上面下载的软件 3 4 5 bin 文件目录添加到系统变量\nvscode 插件插件配置 1. 下载这个插件 stm32-for-vscode 配置3 4 5 的 文件地址\n新建一个cubemx的工程 双击后来到这里 配置引脚 PC13 putout 设置生成选项 点灯 写入反转 在 /* USER CODE BEGIN 3 */和 /* USER CODE END 3 */ 之间 如图所示：\nbuild 和 flsah build flash ","date":"2024-11-20T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320175246956.png","permalink":"https://clingyang.github.io/p/stm32cubemx-vscode-gcc-makefile-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"stm32cubemx+VSCODE+GCC+makefile 开发环境搭建"}]