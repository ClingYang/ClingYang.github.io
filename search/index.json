[{"content":"å…³äºä¸»ä»»åŠ¡å‡½æ•° ä¹‹å‰å†™åˆ°åœ¨ä¸»å‡½æ•°é‡Œé¢å¤„ç†çš„äº‹ä»¶ä¹Ÿä¸çŸ¥é“æœ‰æ²¡æœ‰é—®é¢˜ ä¹‹æ‰€ä»¥è¿™ä¹ˆå†™æ˜¯å› ä¸ºæˆ‘è§‰å¾—å¦‚æœå…¨ç”¨cubemaxé…ç½®å¥½çš„è¯ä¸‹æ¬¡å¦‚æœæ¢ä¸»æ§å¯èƒ½ä¼šæ¯”è¾ƒéº»çƒ¦ æ‰€ä»¥ä»Šå¤©å†ç»†çœ‹ä¸€ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void AppTaskCreate(void) { taskENTER_CRITICAL(); // è¿›å…¥ä¸´ç•ŒåŒº BaseType_t xReturn = pdPASS; /* å®šä¹‰ä¸€ä¸ªåˆ›å»ºä¿¡æ¯è¿”å›å€¼ï¼Œé»˜è®¤ä¸ºpdPASS */ uint32_t count = 0; /* åˆ›å»ºTest_Taskä»»åŠ¡ */ xReturn = xTaskCreate((TaskFunction_t)color_led_task_fun, /* ä»»åŠ¡å…¥å£å‡½æ•° */ (const char *)\u0026#34;COLOR_LED_TASK\u0026#34;, /* ä»»åŠ¡åå­— */ (uint16_t)256, /* ä»»åŠ¡æ ˆå¤§å° */ (void *)NULL, /* ä»»åŠ¡å…¥å£å‡½æ•°å‚æ•° */ (UBaseType_t)osPriorityNormal, /* ä»»åŠ¡çš„ä¼˜å…ˆçº§ */ (TaskHandle_t *)\u0026amp;COLOR_LED_Handle); /* ä»»åŠ¡æ§åˆ¶å—æŒ‡é’ˆ */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;COLOR_LED_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); /* è¿è¡Œå ç”¨ */ memset(pcWriteBuffer, 0, 400); vTaskList(pcWriteBuffer); // è·å–å†…å­˜ä¿¡æ¯ UART1_Printf(\u0026#34;\\r\\n\u0026#34;); UART1_Printf(\u0026#34;%s\\n\\r\u0026#34;, pcWriteBuffer); memset(pcWriteBuffer, 0, 400); vTaskGetRunTimeStats(pcWriteBuffer); // è·å–CPUå ç”¨ç‡ä¿¡æ¯ UART1_Printf(\u0026#34;\\r\\n\u0026#34;); UART1_Printf(\u0026#34;%s\\n\\r\u0026#34;, pcWriteBuffer); return; error: UART1_Printf(\u0026#34;App_Task_Create[error]:Task Create fail,system exception\\n\u0026#34;); while (1) { UART1_Printf(\u0026#34;error count:%d\\n\u0026#34;, (int)count++); app_main_delay_ms(1000); } taskEXIT_CRITICAL(); // é€€å‡ºä¸´ç•ŒåŒº } åˆæ·»åŠ äº†ä¸€äº›åŠŸèƒ½\nä¸²å£å°±ä¼šæ‰“å°å‡ºè¿™æ ·çš„å†…å®¹ å½“ç„¶åœ¨è¿™ä¹‹å‰è¿˜æ˜¯è¦åœ¨cubemaxé‡Œé¢æ‰“å¼€ä¸€äº›ä¸œè¥¿ å‚è€ƒé“¾æ¥ å…¨éƒ¨æ‰“å¼€å˜æˆEnable æ¯æ¬¡é…ç½®ä»»åŠ¡å°±å¯ä»¥è¿™æ ·è¿›è¡Œ ä¿®æ”¹å¦‚ä¸‹ å½“ç„¶åº”ç”¨å‡½æ•°è¿˜æ˜¯å¾—è¦ä½ è‡ªå·±å†™çš„ è¿™æ ·å¥½å¤„æˆ‘æ„Ÿè§‰å°±æ˜¯åˆ°æ—¶å€™ä½ è¦æ˜¯è¿ç§»èŠ¯ç‰‡ä¿®æ”¹çš„åº”è¯¥ä¸æ˜¯å¾ˆå¤§\n","date":"2025-03-20T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320144944405.png","permalink":"https://clingyang.github.io/p/hal_freertos%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%952/","title":"HAL_Freertosçš„ä½¿ç”¨è®°å½•2"},{"content":"ä¸ºäº†ä¿å­˜å·¥ä½œçŠ¶æ€ é•¿æŒ‰å…³æœºåæˆ–è€…30åˆ†é’Ÿåæ–­ç”µ åœ¨è¿™ä¸ªæ“ä½œå‰å…ˆä¿å­˜çŠ¶æ€ ä¸‹æ¬¡å¼€æœºæ—¶ç›´æ¥è¯»å–ä¿å­˜å†…å®¹ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026#34;Flash_baup.h\u0026#34; void SaveStateToFlash(uint8_t level, uint8_t reverse) { // è§£é” Flash HAL_FLASH_Unlock(); // æ“¦é™¤ Flash é¡µ FLASH_EraseInitTypeDef EraseInitStruct; uint32_t PageError = 0; EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; EraseInitStruct.PageAddress = FLASH_USER_START_ADDR; EraseInitStruct.NbPages = 1; if (HAL_FLASHEx_Erase(\u0026amp;EraseInitStruct, \u0026amp;PageError) != HAL_OK) { // é”™è¯¯å¤„ç† Error_Handler(); } // å†™å…¥å½“å‰æ¡£ä½å’Œæ­£åè½¬çŠ¶æ€ uint32_t data = (level \u0026lt;\u0026lt; 8) | reverse; if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, FLASH_USER_START_ADDR, data) != HAL_OK) { // é”™è¯¯å¤„ç† Error_Handler(); } // é”å®š Flash HAL_FLASH_Lock(); } void LoadStateFromFlash(uint8_t *level, uint8_t *reverse) { uint32_t data = *(__IO uint32_t*)FLASH_USER_START_ADDR; *level = (data \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; *reverse = data \u0026amp; 0xFF; } å¤´æ–‡ä»¶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #ifndef FLASH_BAUP_H #define FLASH_BAUP_H #include \u0026#34;stm32f0xx_hal.h\u0026#34; #include \u0026#34;main.h\u0026#34; // å®šä¹‰ Flash å­˜å‚¨åœ°å€ #define FLASH_USER_START_ADDR ((uint32_t)0x08007000) /* Start @ of user Flash area, assuming 1KB per page and 128KB total Flash size */ // Flash æ“ä½œå‡½æ•°å£°æ˜ void SaveStateToFlash(uint8_t level, uint8_t reverse); void LoadStateFromFlash(uint8_t *level, uint8_t *reverse); #endif // FLASH_BAUP_H ä¿å­˜çš„æ˜¯ä¸¤ä¸ª uint8_t çš„æ•°æ® å€¼å¾—æ³¨æ„çš„æ˜¯æˆ‘ä»¬è¦æ³¨æ„åœ°å€ å­˜å‚¨çš„èµ·å§‹åœ°å€æœ‰è®²ç©¶çš„ æœ€åé€šè¿‡keil ä¹Ÿæ˜¯èƒ½çœ‹åˆ°çš„ å¦‚æœèµ„æºç´§å¼  å¯ä»¥debug ä¸€ä¸‹ ","date":"2025-03-20T11:46:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145049973.png","permalink":"https://clingyang.github.io/p/hal_flash-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%AF%BB%E5%8F%96/","title":"HAL_flash æ•°æ®å¤‡ä»½ä¸è¯»å–"},{"content":"æœ€è¿‘å…¥äº†ä¸€ä¸ªESP32 å…„å¼Ÿä»¬ï¼Œè¿™ç©æ„è¿˜å¯ä»¥ï¼Œä¹°æ¥è‚¯å®šæ˜¯ç»™å®ƒç‚¹äº®å•Šå¯¹å§ æˆ‘å°±æ˜¯ç‚¹ç¯ä¾ ğŸ‡ ğŸ˜­åƒä¸‡ä¸è¦ä¸æ¥å¤©çº¿å•Šï¼Œä¸ç„¶ä½ ä¼šä¸€ç›´æ‰¾ä¸åˆ°ä½ çš„wifi 1.ç‚¹ç¯ç¬¬ä¸€æ­¥ä½ å¾—æœ‰IDE == Arduino å°±æ˜¯è¿™ä¸ªç»¿ä¸œè¥¿\nå¯æ˜¯æ€ä¹ˆä¸‹è½½å®‰è£…å‘¢ï¼Ÿè‡ªå·±ç™¾åº¦å§ï¼Œå½“ç„¶ä½ è¦æ˜¯æ‡’è¿™è¾¹ä¹Ÿç»™æ‚¨é™„åŠ äº†è¿æ¥\nArduino å®‰è£… \u0026mdash;è¿™é‡Œä½œè€…è®¤ä¸ºä½ çœ‹è¿æ¥å¹¶ä¸”ä½ å®‰è£…å¥½äº†\n2023/5/2 å€¼å¾—æ³¨æ„çš„æ˜¯ è¿™ä¸ªsdkä½ éœ€è¦ä»¥ç®¡ç†å‘˜çš„èº«ä»½å»è¿è¡Œ\nok ç°åœ¨è¿›å…¥ç¬¬äºŒæ­¥\n2.ç¼–å†™ç‚¹ç¯ç¨‹åº 1 2 3 4 5 6 7 8 9 10 11 12 13 const int LED = 2; void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } çƒ§å½• ä¸€å®šè¦é€‰ä¸²å£\nä¸Šä¼  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 é¡¹ç›®ä½¿ç”¨äº† 219045 å­—èŠ‚ï¼Œå ç”¨äº† (16%) ç¨‹åºå­˜å‚¨ç©ºé—´ã€‚æœ€å¤§ä¸º 1310720 å­—èŠ‚ã€‚ å…¨å±€å˜é‡ä½¿ç”¨äº†16088å­—èŠ‚ï¼Œ(4%)çš„åŠ¨æ€å†…å­˜ï¼Œä½™ç•™311592å­—èŠ‚å±€éƒ¨å˜é‡ã€‚æœ€å¤§ä¸º327680å­—èŠ‚ã€‚ esptool.py v3.3 Serial port COM4 Connecting...... Chip is ESP32-D0WD-V3 (revision 3) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: e8:31:cd:74:1c:84 Uploading stub... Running stub... Stub running... Changing baud rate to 921600 Changed. Configuring flash size... Flash will be erased from 0x00001000 to 0x00005fff... Flash will be erased from 0x00008000 to 0x00008fff... Flash will be erased from 0x0000e000 to 0x0000ffff... Flash will be erased from 0x00010000 to 0x00045fff... Flash params set to 0x022f Compressed 18880 bytes to 12992... Writing at 0x00001000... (100 %) Wrote 18880 bytes (12992 compressed) at 0x00001000 in 0.5 seconds (effective 279.9 kbit/s)... Hash of data verified. Compressed 3072 bytes to 128... Writing at 0x00008000... (100 %) Wrote 3072 bytes (128 compressed) at 0x00008000 in 0.1 seconds (effective 350.9 kbit/s)... Hash of data verified. Compressed 8192 bytes to 47... Writing at 0x0000e000... (100 %) Wrote 8192 bytes (47 compressed) at 0x0000e000 in 0.1 seconds (effective 490.3 kbit/s)... Hash of data verified. Compressed 219440 bytes to 120828... Writing at 0x00010000... (12 %) Writing at 0x0001d956... (25 %) Writing at 0x00022fd3... (37 %) Writing at 0x00028288... (50 %) Writing at 0x0002d6ef... (62 %) Writing at 0x00035f5d... (75 %) Writing at 0x0003e042... (87 %) Writing at 0x000438e3... (100 %) Wrote 219440 bytes (120828 compressed) at 0x00010000 in 2.4 seconds (effective 722.3 kbit/s)... Hash of data verified çƒ§å†™æˆåŠŸçœ‹ä½ çš„æ¿å­æ˜¯ä¸æ˜¯åœ¨blink blink âœ¨âœ¨âœ¨âœ¨ç‚¹ç¯è§†é¢‘ ","date":"2025-03-20T11:08:09+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145935000.png","permalink":"https://clingyang.github.io/p/esp32-arduino-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"ESP32 ARDUINO å¼€å‘ç¯å¢ƒæ­å»º"},{"content":"æ–‡ç« é»˜è®¤æ ¼å¼æ¨¡ç‰ˆ æ¨èåœ¨æ¨¡æ¿ä¸­è®¾ç½®ï¼Œä¿®æ”¹ archetypes/default.mdï¼ˆå¦‚æœæ²¡æœ‰åˆ™æ–°å»ºä¸€ä¸ªå³å¯ï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- date : \u0026#39;{{ .Date }}\u0026#39; draft: true title: \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; image: https://picsum.photos/800/600.webp?random={{ substr (md5 (.Date)) 4 8 }} description: æè¿° summary: æ–‡ç« æ‘˜è¦ï¼Œé‡è¦ï¼å…³ä¹ESOæœç´¢å¼•æ“ä¼˜åŒ– categories: [ \u0026#34;hugo\u0026#34;, \u0026#34;ç¬”è®°\u0026#34;, ] tags: [ \u0026#34;hugo\u0026#34;, \u0026#34;ç¬”è®°\u0026#34; ] --- è¿™é‡Œçš„é‡ç‚¹æ˜¯ image è¿™ä¸€è¡Œï¼Œå³ä½¿ç”¨äº† Lorem Picsum çš„æ¥å£ï¼Œç„¶åå°±å¯ä»¥å¾—åˆ°ä¸€å¼ éšæœºçš„å›¾ç‰‡ï¼Œæ›´å¤šè¯¦æƒ…ä¹Ÿå¯å‰å¾€ Lorem Picsum äº†è§£ã€‚ ä¹‹åï¼Œæˆ‘ä»¬é€šè¿‡ hugo new å‘½ä»¤æ—¶ï¼Œæ–°å»ºçš„æ–‡ç« ä¼šéšæœºåŒ¹é…ä¸€å¼ å›¾ç‰‡\næ–‡ç« çš„ä¸€å†™å˜é‡çš„å†™æ³• è¯´æ˜tags ä¸€èˆ¬æ˜¯åœ¨æ–‡ç« å†…éƒ¨çš„æ ‡é¢˜ æˆ‘è¿˜è¦ä¿®æ”¹å›¾ç‰‡ç²˜è´´è·¯å¾„ åœ¨vscode è®¾ç½®é‡Œé¢ è¯„è®ºåŒºæˆ‘æˆäº† å‚è€ƒé“¾æ¥ æ•ˆæœå¯ä»¥çœ‹æˆ‘è¯„è®ºåŒº\n1 2 3 4 #åˆ›å»ºæ–°çš„ç¬”è®°æ˜¯ .\\hugo new content post/Blogname/index.md # æœ¬åœ°è°ƒè¯•å¯åŠ¨æœåŠ¡ .\\hugo server -D æ–‡ç« å›¾ç‰‡ æ“ä½œ ã€Hugoã€‘markdownä¸­å›¾ç‰‡å¤§å°å’Œå¯¹é½æ–¹å¼è°ƒæ•´\nè„šæœ¬è‡ªåŠ¨åŒ– åœ¨vscode æˆ‘å»ºç«‹äº†ä¸€ä¸ªå·¥ä½œåŒº å†™äº†ä¸€äº›ä¸ªè„šæœ¬ æ–°å»ºæ–‡ç«  åˆ é™¤æ–‡ç«  æœ¬åœ°é¢„è§ˆ æ›´æ–°è¿œç¨‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 { \u0026#34;folders\u0026#34;: [ { \u0026#34;path\u0026#34;: \u0026#34;..\u0026#34; } ], \u0026#34;settings\u0026#34;: { \u0026#34;VsCodeTaskButtons.tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;$(zap)New\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;New\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;åˆ›å»ºä¸€ä¸ªæ–°æ–‡ç« \u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;$(notebook-delete-cell) Clean\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;clean\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;åˆ é™¤æŒ‡å®šæ–‡ç« \u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;$(globe)localview\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;localview\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;æœ¬åœ°é¢„è§ˆ\u0026#34; }, ] }, \u0026#34;tasks\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;New\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;./hugo.exe new content post/${input:Blogname}/index.md\u0026#34;, }, { \u0026#34;label\u0026#34;: \u0026#34;clean\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;Remove-Item -Recurse -Force -Path ${workspaceFolder}\\\\content\\\\post\\\\${input:cleanBlogname}\u0026#34;, }, { \u0026#34;label\u0026#34;: \u0026#34;localview\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;./hugo.exe server -D\u0026#34;, }, ], \u0026#34;inputs\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Blogname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;è¾“å…¥æ–‡ç« åå­—\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;Blogname\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;cleanBlogname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;è¾“å…¥éœ€è¦åˆ é™¤æ–‡ç« åå­—\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;cleanBlogname\u0026#34; }, ] } } åœ¨ VSCode çš„ tasks.json æ–‡ä»¶ä¸­ï¼Œ$(zap) æ˜¯ä¸€ä¸ªå›¾æ ‡åç§°ï¼Œç”¨äºåœ¨ä»»åŠ¡åˆ—è¡¨ä¸­æ˜¾ç¤ºä¸€ä¸ªå›¾æ ‡ã€‚è¿™äº›å›¾æ ‡åç§°æ˜¯ VSCode çš„å†…ç½®å›¾æ ‡ï¼Œç”¨äºåœ¨ç”¨æˆ·ç•Œé¢ä¸­æä¾›è§†è§‰æç¤ºã€‚\nVSCode çš„å›¾æ ‡åç§°æ˜¯åŸºäº Octicons å›¾æ ‡é›†çš„ã€‚Octicons æ˜¯ GitHub çš„å®˜æ–¹å›¾æ ‡é›†ï¼Œå¹¿æ³›ç”¨äº VSCode çš„ç•Œé¢ä¸­ã€‚ä»¥ä¸‹æ˜¯ä¸€äº›å¸¸ç”¨çš„å›¾æ ‡åç§°ç¤ºä¾‹ï¼š\n$(zap) - é—ªç”µå›¾æ ‡ï¼Œé€šå¸¸ç”¨äºè¡¨ç¤ºå¿«é€Ÿæˆ–å¼ºå¤§çš„æ“ä½œ. $(gear) - é½¿è½®å›¾æ ‡ï¼Œé€šå¸¸ç”¨äºè®¾ç½®æˆ–é…ç½®ç›¸å…³çš„æ“ä½œ. $(file) - æ–‡ä»¶å›¾æ ‡ï¼Œç”¨äºè¡¨ç¤ºæ–‡ä»¶ç›¸å…³çš„æ“ä½œ. $(trash) - åƒåœ¾æ¡¶å›¾æ ‡ï¼Œç”¨äºè¡¨ç¤ºåˆ é™¤æˆ–æ¸…ç†ç›¸å…³çš„æ“ä½œ. ä½ å¯ä»¥åœ¨ VSCode çš„ä»»åŠ¡é…ç½®ä¸­ä½¿ç”¨è¿™äº›å›¾æ ‡åç§°æ¥ä¸ºä»»åŠ¡æ·»åŠ è§†è§‰æ•ˆæœï¼Œä½¿ä»»åŠ¡åˆ—è¡¨æ›´åŠ ç›´è§‚å’Œæ˜“äºç†è§£.\nå¦‚æœä½ éœ€è¦æŸ¥æ‰¾æ›´å¤šçš„å›¾æ ‡åç§°ï¼Œå¯ä»¥å‚è€ƒ Octicons çš„å®˜æ–¹æ–‡æ¡£ï¼Œå…¶ä¸­åˆ—å‡ºäº†æ‰€æœ‰å¯ç”¨çš„å›¾æ ‡åŠå…¶åç§°.\nå¤–é“¾å›¾ç‰‡å›¾åºŠ ä¸ææ„Ÿè§‰ä¼šç‚¸\nå‚è€ƒé“¾æ¥1\nå‚è€ƒé“¾æ¥2 å‚è€ƒè¿æ¥3\n1 2 3 4 å¦‚æœåŠ é€Ÿæºæ— æ³•ä½¿ç”¨å¯ä»¥æ›´æ”¹åŠ é€Ÿæºï¼Œå°†githubçš„è®¾å®šè‡ªå®šä¹‰åŸŸåå¤„çš„cdn.jsdmirror.comæ”¹ä¸ºå…¶ä»–åŠ é€Ÿæº jsd.onmicrosoft.cn gcore.jsdelivr.net testingcf.jsdelivr.net ä¸‹é¢è¿™å¼ å›¾æ˜¯å›¾åºŠä¸Šçš„ è¿˜æœ‰ä¸€äº›é“¾æ¥å»ºç«‹ç½‘ç«™æ—¶å€™ç”¨çš„ https://www.hughh.top/posts/hugo-guide/\n","date":"2025-02-18T11:13:00+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145323127.png","permalink":"https://clingyang.github.io/p/hugo%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E%E8%AE%B0%E8%BD%BD%E7%AC%94%E8%AE%B0/","title":"hugoæ ¼å¼è¯´æ˜è®°è½½ç¬”è®°"},{"content":"ç¯å¢ƒæ­å»º ç¯å¢ƒæ­å»ºåç¬¬ä¸€æ®µä»£ç \n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; void taskA(void *pvParameter) { while (1) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Task 1\u0026#34;); vTaskDelay(pdMS_TO_TICKS(500)); } } void app_main(void) { // tskNO_AFFINITY åŒæ ¸éƒ½å¯ä»¥è¿è¡Œ xTaskCreatePinnedToCore(taskA, \u0026#34;taskA\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); } main æ˜¯ç‰¹æ®Šçš„ç»„ä»¶\nä»»åŠ¡åŒæ­¥ é˜Ÿåˆ— 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;freertos/queue.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; QueueHandle_t Queue_handle = NULL; typedef struct { int a; int b; } QueueMessage_t; void taksA(void *pvParameter) { QueueMessage_t message; message.a = 1; message.b = 2; while (1) { if (xQueueSend(Queue_handle, \u0026amp;message, 0) == pdTRUE) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Send success\u0026#34;); } else { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Send failed\u0026#34;); } message.a++; message.b++; vTaskDelay(pdMS_TO_TICKS(500)); } } void taksB(void *pvParameter) { QueueMessage_t message; while (1) { if (pdTRUE == xQueueReceive(Queue_handle, \u0026amp;message, 0)) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Receive success\u0026#34;); ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;a=%d, b=%d\u0026#34;, message.a, message.b); } else { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Receive failed\u0026#34;); } vTaskDelay(pdMS_TO_TICKS(500)); } } void app_main(void) { Queue_handle = xQueueCreate(10, sizeof(QueueMessage_t)); if (NULL == Queue_handle ) { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Queue create failed\u0026#34;); } else { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Queue create success\u0026#34;); } xTaskCreatePinnedToCore(taksA, \u0026#34;taksA\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); xTaskCreatePinnedToCore(taksB, \u0026#34;taksB\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); } ä¿¡å·é‡ ä»»åŠ¡ä¿æŠ¤ç¡¬ä»¶æœºåˆ¶ äº‹ä»¶ç»„ ç›´è¾¾ä»»åŠ¡é€šçŸ¥ åŸç”ŸåŒºåˆ« GPIO æ“ä½œ ç¯å¢ƒæ­å»º ä¹é‘«å®˜æ–¹æ–‡ç«  text text ","date":"2025-01-08T23:58:10+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145836481.png","permalink":"https://clingyang.github.io/p/esp_note/","title":"ESP_Note"},{"content":"å‰è¨€ æˆ‘ä»¬æœ‰äº›ç¨‹åºåœ¨æ‰§è¡Œæˆ–è€…å’Œä¸‹ä½å‡ äº¤äº’çš„è¿‡ç¨‹ä¸­å¯èƒ½ä¼šå‡ºç°ä¸‹ä½æœºç¡¬æ€§è§„å®šéœ€è¦ç­‰å¾…å¤šå°‘ç§’çš„æƒ…å†µç„¶è€Œæˆ‘ä»¬çš„ç¨‹åºåˆå¿…é¡»å¾—æ‰§è¡Œä¸‹å»è¿™æ ·ä¼šé€ æˆå•ç‰‡æœºå¤§é‡èµ„æºå‡ºç°è¿‡åº¦æµªè´¹çš„æƒ…å†µè§£å†³è¿™ç§é—®é¢˜çš„åŠæ³•æœ‰å¾ˆå¤šã€‚\nåˆ†äº«ä¸€ç§æ€è·¯ 1.åˆ›å»ºä¸€ä¸ªms(æ¯«ç§’)çº§å»¶æ—¶ä¸­æ–­ 2.åˆ›å»ºè®¡æ•°çš„å˜é‡ 3.åœ¨éœ€è¦å»¶æ—¶çš„å‡½æ•°ä¸­å¯¹å˜é‡é˜ˆå€¼è¿›è¡Œåˆ¤æ–­ 4.éªŒè¯å®ä¾‹\u0026ndash;å®Œæ•´ä½¿ç”¨è®°å½•ä»£ç \nCubemaxåˆ›å»ºä¸€ä¸ªmså®šæ—¶å™¨å¾ˆç®€å•è¿™é‡Œä¸èµ˜è¿°é™„ä¸Šå‚è€ƒé“¾æ¥ï¼š\nSTM32CubeMXå­¦ä¹ ç¬”è®°ï¼ˆ5ï¼‰â€”â€”åŸºæœ¬å®šæ—¶å™¨æ¥å£ä½¿ç”¨\nuint32_t time = 0;\nextern uint32_t time;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if(htim-\u0026gt;Instance == TIM7) // å®šæ—¶å™¨6åŸºåœ°å€ { â€‹ // è‡ªå®šä¹‰åº”ç”¨ç¨‹åº â€‹ time++; // æ¯1msè¿›æ¥1æ¬¡ } } ä¸šåŠ¡é€»è¾‘ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ â€‹ if(time == 1000) // æ¯1ç§’LEDç¯ç¿»è½¬ä¸€æ¬¡ â€‹ { â€‹ HAL_GPIO_TogglePin(LED_G_GPIO_Port,LED_G_Pin); â€‹ time = 0; â€‹ } } è¿™æ ·å°±èƒ½åšåˆ°æ¯ç§’è§¦å‘ä¸€æ¬¡å°‘å ç”¨èµ„æºäº†\né—®é¢˜ if(time == 1000)\nè¿™é‡Œæˆ‘ä»¬æ˜¯è®©å®ƒåˆ°è¾¾1000msæ—¶ å°±è§¦å‘ä¸šåŠ¡å‡½æ•° å¦‚è‹¥å•ä¸šåŠ¡é€»è¾‘æ¯”è¾ƒå¤šæ—¶\næ­¤æ—¶åˆ°è¾¾1000ms æ—¶ if æ¥ä¸åŠåˆ¤æ–­ é‚£ä¹ˆ è¿™ä¸ªå‡½æ•°æ°¸è¿œæ²¡æœ‰æ‰§è¡Œ é‚£ä¹ˆ è¿™ç§æƒ…å†µå¦‚ä½•å¤„ç† ï¼Ÿ\nå¦‚æœæ˜¯æ¢æˆif(time \u0026gt;= 1000)\nåˆé‚£ä¹ˆè¶…è¿‡äº†å¤šå°‘ä¸ªmså‘¢ï¼Ÿ\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321152335834.png","permalink":"https://clingyang.github.io/p/hal_cubemx%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"HAL_Cubemxå®šæ—¶å™¨ä½¿ç”¨è®°å½•"},{"content":"â€‚é¢å¯¹æ— è§„å¾‹é•¿åº¦çš„æ•°æ®å¸§å¦‚ä½•å¤„ç†ï¼Ÿ ä¸å®šé•¿æ•°æ®æ¥æ”¶å¯ä»¥ä½¿ç”¨æ¯å¸§æ•°æ®å‘é€å®Œæˆåä¼šæœ‰ä¸€å®šçš„ç©ºé—²æ—¶é—´\u0026quot;å¸§çš„æ—¶é—´é—´éš”?\u0026quot; å¦‚æœä½ æƒ³æ¯å¸§éƒ½è¦å¯ä»¥é‡‡ç”¨dmaåŠ ç©ºé—²ä¸­æ–­çš„æ–¹å¼ç©ºé—²ä¸­æ–­ä¸€æ¬¡å°±æ˜¯ä¸€å¸§æ•°æ®æ¥å—å®Œæˆå†å»åšå…¶å®ƒæ•°æ®è§£æå’Œå…¶ä»–ä¸šåŠ¡å‡ºæ¥ä¸è¿‡éœ€è¦æˆ‘ä»¬æ³¨æ„çš„æ˜¯è¿™é‡Œé¢æœ‰ä¸ªå°å‘ __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1);\næˆ‘å…ˆè¯´ä¸‹å¦‚ä½•å¤„ç†ï¼š 1 2 3 4 5 6 7 8 9 10 11 if (__HAL_UART_GET_FLAG(\u0026amp;huart1,UART_FLAG_IDLE)== SET) { uint16_t temp = 0; __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1); HAL_UART_DMAStop(\u0026amp;huart1); temp = huart1.Instance-\u0026gt;SR; temp = huart1.Instance-\u0026gt;DR; temp = hdma_usart1_rx.Instance-\u0026gt;CNDTR; Usart1type.UsartDMARecLen = USART1_DMA_REC_SIE - temp; HAL_UART_RxCpltCallback(\u0026amp;huart1); } è¿™ä¸ªå‡½æ•°ç½‘ä¸Šè¯´ä»€ä¹ˆæœ‰bugè¿˜æ˜¯å•¥ temp = huart1.Instance-\u0026gt;SR;\ntemp = huart1.Instance-\u0026gt;DR;\nè¿˜è¦è¯»ä¸€ä¸‹è¿™ä¸¤å¯„å­˜å™¨\nåŸç†å¾ˆç®€å•å°±æ˜¯æ‰“å¼€ç©ºé—²ä¸­æ–­å‡½æ•°\nè§¦å‘ä¸­æ–­ådmaæ¥æ”¶\næ¥æ”¶å®Œåæ¬åˆ°æ¥æ”¶æ•°ç»„é‡Œé¢æ¸…é™¤dmaæ•°ç»„\nåšä¸šåŠ¡é€»è¾‘å¤„ç† å¤„ç†å®Œå°±å…¨éƒ¨æ•°ç»„æ¸…é™¤\næ“ä½œæ­¥éª¤å¦‚ä¸‹ï¼š 1.å¼€å¯ä¸­æ–­å‡½æ•°\n1 2 3 4 5 6 7 8 9 10 11 void EnableUsart_IT(void){ __HAL_UART_ENABLE_IT(\u0026amp;huart1,UART_IT_RXNE); __HAL_UART_ENABLE_IT(\u0026amp;huart1,UART_IT_IDLE); __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1); HAL_UART_Receive_DMA(\u0026amp;huart1,Usart1type.Usart1DMARecBuffer,USART1_DMA_REC_SIE); } 2.è§¦å‘ä¸­æ–­ådmaæ¥æ”¶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 void USART1_IRQHandler(void) { /* USER CODE BEGIN USART1_IRQn 0 */ if (__HAL_UART_GET_FLAG(\u0026amp;huart1,UART_FLAG_IDLE)== SET) { uint16_t temp = 0; __HAL_UART_CLEAR_IDLEFLAG(\u0026amp;huart1); HAL_UART_DMAStop(\u0026amp;huart1); temp = huart1.Instance-\u0026gt;SR; temp = huart1.Instance-\u0026gt;DR; temp = hdma_usart1_rx.Instance-\u0026gt;CNDTR; Usart1type.UsartDMARecLen = USART1_DMA_REC_SIE - temp; HAL_UART_RxCpltCallback(\u0026amp;huart1); } /* USER CODE END USART1_IRQn 0 */ HAL_UART_IRQHandler(\u0026amp;huart1); /* USER CODE BEGIN USART1_IRQn 1 */ HAL_UART_Receive_DMA(\u0026amp;huart1,Usart1type.Usart1DMARecBuffer,USART1_DMA_REC_SIE); //å†æ¬¡æ‰“å¼€DMAæ¥æ”¶ /* USER CODE END USART1_IRQn 1 */ } 3.æ¥æ”¶å®Œåæ¬åˆ°æ¥æ”¶æ•°ç»„é‡Œé¢æ¸…é™¤dmaæ•°ç»„\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* USER CODE BEGIN 1 */ void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){ if (huart-\u0026gt;Instance==USART1) { memcpy(\u0026amp;Usart1type.Usart1RecBuffer[Usart1type.UsartRecLen],Usart1type.Usart1DMARecBuffer,Usart1type.UsartDMARecLen); Usart1type.UsartRecLen=Usart1type.UsartDMARecLen; memset(Usart1type.Usart1DMARecBuffer,0x00,sizeof(Usart1type.Usart1DMARecBuffer)); Usart1type.UsartRecFlag=1; } } 4.ä¸šåŠ¡é€»è¾‘å¤„ç†\næˆ‘å°±ç®€å•çš„ä¸²å£æ‰“å°æµ‹è¯•\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { if (Usart1type.UsartRecFlag==1 ) { â€‹ printf(\u0026#34;re:%s,len%d\\r\\n\u0026#34;,Usart1type.Usart1RecBuffer,Usart1type.UsartDMARecLen); â€‹ memset(Usart1type.Usart1RecBuffer,0x00,sizeof(Usart1type.Usart1RecBuffer)); â€‹ Usart1type.UsartRecFlag=0; â€‹ Usart1type.UsartRecLen=0; } /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } å‚è€ƒä»£ç ï¼šå°±ä¸€ç§¯åˆ† ç»™æˆ‘ç‚¹\nä¸²å£ç©ºé—²ä¸­æ–­cubemaxä»»æ„é•¿åº¦æ•°æ®èµ„æº-CSDNæ–‡åº“ ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321093939084.png","permalink":"https://clingyang.github.io/p/hal_dma%E4%B8%AD%E6%96%AD%E7%A9%BA%E9%97%B2%E6%8E%A5%E5%8F%97%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE1/","title":"HAL_DMAä¸­æ–­ç©ºé—²æ¥å—ä¸å®šé•¿æ•°æ®1"},{"content":"ç©ºé—²ä¸­æ–­ + dma ä¸Šæ¬¡é‚£ç¯‡æ–‡ç« ç¡®å®æ²¡æœ‰å¥½å¥½ä½¿ç”¨å¥½HALåº“ ç°åœ¨ é‡æ–°å†æ¥å†™ä¸€ä¸ª è¿™ä¸ªæ˜¯DMA æ”¶å‘ åªéœ€è¦åœ¨cubmaxé‡Œé¢æ‰“å¼€DMAè®¾ç½® å’Œ ä¸­æ–­ å°±è¡Œ ç„¶åå°±æ˜¯ä»£ç  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 extern UART_HandleTypeDef huart1; void test_task_fun(void *arg){ const char t_data[]={\u0026#34;-----------\\n\u0026#34;}; char tbuf[128]; char rbuf[128]; memset(tbuf,0,sizeof(tbuf)); memset(rbuf,0,sizeof(rbuf)); __HAL_UART_ENABLE_IT(\u0026amp;huart1,UART_IT_IDLE); HAL_UART_Transmit_DMA(\u0026amp;huart1, (uint8_t*)t_data, strlen(t_data)); /* Infinite loop */ for(;;) { if(HAL_UARTEx_ReceiveToIdle_DMA(\u0026amp;huart1, (uint8_t*)rbuf, sizeof(rbuf)-1)==HAL_OK)\t{ memcpy(tbuf,rbuf,sizeof(rbuf)); HAL_UART_Transmit_DMA(\u0026amp;huart1, (uint8_t*)tbuf, strlen(tbuf)); }\tosDelay(1); } } ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321093939084.png","permalink":"https://clingyang.github.io/p/hal_dma%E4%B8%AD%E6%96%AD%E7%A9%BA%E9%97%B2%E6%8E%A5%E5%8F%97%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE2/","title":"HAL_DMAä¸­æ–­ç©ºé—²æ¥å—ä¸å®šé•¿æ•°æ®2"},{"content":"æ—¨åœ¨äºå¤šä¸²å£ä½¿ç”¨printf é‡å®šä¹‰ myprintf.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026#34;myprintf.h\u0026#34; #include \u0026#34;stm32f1xx_hal.h\u0026#34; #include \u0026lt;stdarg.h\u0026gt; // va_list va_start va_end #include \u0026lt;stdio.h\u0026gt; // sprintf #include \u0026lt;string.h\u0026gt; // strlen extern UART_HandleTypeDef huart1; void UART1_Printf(const char* fmt, ...) { char buff[64]; va_list args; va_start(args, fmt); vsnprintf(buff, sizeof(buff), fmt, args); HAL_UART_Transmit(\u0026amp;huart1, (uint8_t*)buff, strlen(buff), HAL_MAX_DELAY); va_end(args); } myprintf.h 1 2 3 4 5 6 7 8 9 10 11 12 #ifndef __MYPRINTF_H_ #define __MYPRINTF_H_ #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif void UART1_Printf(const char* fmt, ...); #ifdef __cplusplus } #endif #endif ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321093232384.png","permalink":"https://clingyang.github.io/p/hal_printf-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E4%B8%B2%E5%8F%A3%E6%89%93%E5%8D%B0/","title":"HAL_Printf è‡ªå®šä¹‰å¤šä¸ªä¸²å£æ‰“å°"},{"content":"å¼•è¨€ HAL_PWMé…ç½®å ç©ºæ¯”é¢‘ç‡ è®²è§£å ç©ºæ¯”é¢‘ç‡ é…ç½®å ç©ºæ¯”é¢‘ç‡ å®šæ—¶å™¨ ä¹‹é—´çš„å…³ç³»ä»¥åŠå‚æ•°é…ç½®\nå‚è€ƒè¿æ¥ 1.STM32CubeMXå­¦ä¹ ç¬”è®°ï¼ˆ13ï¼‰â€”â€”PWMè¾“å‡º(å‘¼å¸ç¯)ä½¿ç”¨ 2.STM32æ ‡å‡†åº“+HALåº“ | é«˜ç²¾åº¦åŠ¨æ€è°ƒèŠ‚PWMè¾“å‡ºé¢‘ç‡+å ç©ºæ¯”\nçœ‹ä½ cubemx é‡Œé¢çš„é…ç½®æ—¶é’Ÿé¢‘ç‡æ˜¯å¤šå°‘ å‚ç…§ç¬¬äºŒç¯‡æ–‡ç« æè¿°ä¿®æ”¹ ä¸‹é¢ä¿©ä¸ªå‚æ•°å°±è¡Œ uint16_t prescaler\nuint64_t tim_clk_freq\nå®æˆ˜æ“ä½œ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void set_pwm_param(TIM_HandleTypeDef htim, uint32_t Channel, uint32_t freq, uint16_t duty) { uint16_t prescaler = 72-1; uint64_t tim_clk_freq = 72000000; //è®¡ç®—PWMé¢‘ç‡ï¼Œæ‰€å¯¹åº”çš„è‡ªåŠ¨é‡è£…è½½ ---\u0026gt; ARR = ä¸»é¢‘ / (é¢„åˆ†ï¿½?+1) / é¢„æœŸPWMé¢‘ç‡(Hz) - 1 float pwm_freq_arr = (tim_clk_freq * 1.0) / (prescaler+1) / freq * 1.0 - 1; //è®¡ç®—PWMå ç©ºæ¯”ï¼Œå¯¹åº”æ¯”è¾ƒå¯„å­˜å™¨çš„ ---\u0026gt; CCR = é¢„æœŸå ç©ºï¿½? * (è‡ªåŠ¨é‡è£…è½½ï¿½??+1) //å ç©ºæ¯”åˆ™ç”±æ•/æ¯”è¾ƒå¯„å­˜å™¨ï¼ˆTIMx_CRxï¼‰å¯„å­˜å™¨å†³å®šã€‚å ç©ºæ¯”:duty = Pluse / (ARR+1) float pwm_duty_pulse = duty * 1.0 / 100 * (pwm_freq_arr + 1); //é…ç½®PSCé¢„åˆ†é¢‘ __HAL_TIM_SET_PRESCALER(\u0026amp;htim, prescaler); //é…ç½®PWMé¢‘ç‡ ARR __HAL_TIM_SetAutoreload(\u0026amp;htim, (uint16_t)pwm_freq_arr); //é…ç½®PWMå ç©ºæ¯” __HAL_TIM_SetCompare(\u0026amp;htim, Channel, (uint16_t)pwm_duty_pulse); // printf(\u0026#34;pwm_freq_arr:%.2f\\r\\n\u0026#34;, pwm_freq_arr); // printf(\u0026#34;pwm_duty_pulse:%.2f\\r\\n\u0026#34;, pwm_duty_pulse); } ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321150515154.png","permalink":"https://clingyang.github.io/p/hal_pwm%E9%85%8D%E7%BD%AE%E5%8D%A0%E7%A9%BA%E6%AF%94%E9%A2%91%E7%8E%87/","title":"HAL_PWMé…ç½®å ç©ºæ¯”é¢‘ç‡"},{"content":"æ§åˆ¶pwmå¼€å…³ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //å¯åŠ¨å®šæ—¶å™¨ HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim); //å…³é—­å®šæ—¶å™¨ HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim); //å¯åŠ¨æŒ‡å®šé€šé“PWM HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel); //åœæ­¢æŒ‡å®šé€šé“PWM HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel); //è®¾ç½®æŒ‡å®šé€šé“å ç©ºæ¯” void __HAL_TIM_SetCompare(TIM_HandleTypeDef *htim, uint32_t Channel,uint16_t Value); //è®¾ç½®å®šæ—¶å™¨è®¡æ•°å™¨å€¼ coid __HAL_TIM_SetCompare(TIM_HandleTypeDef *htim, uint16_t Value) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 if (sta==0){ HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); } else if(sta==1){ // D=5% HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); D=5; HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); } else if (sta==2){ // 10%â‰¤Dâ‰¤85% HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); D=50; HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); } else if (sta==3){ // 85%\u0026lt;Dâ‰¤90% HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); D=88;HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); /// è¿™é‡Œçš„Start å·²ç»ä¸èµ·ä½œç”¨äº† } ** HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2);\nç›¸å½“äºæŠŠè¿™ä¸ªä¸­æ–­ä½¿èƒ½å…³é—­äº†éœ€è¦åˆ°å¤–éƒ¨å¼€å¯ ** 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 / æŒ‰é”®ä¸­æ–­ void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin==SW1_Pin) { HAL_GPIO_WritePin(GPIOB, LED_G_Pin|LED_B_Pin|LED_R_Pin, GPIO_PIN_SET); HAL_GPIO_TogglePin(LED_G_GPIO_Port,LED_G_Pin); HAL_UART_Transmit(\u0026amp;huart1,\u0026#34;G\u0026#34;, sizeof(\u0026#34;G\u0026#34;)-1, 100); sta--; if(sta==4){ HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); } } else if (GPIO_Pin==SW3_Pin){ HAL_GPIO_WritePin(GPIOB, LED_G_Pin|LED_B_Pin|LED_R_Pin, GPIO_PIN_SET); HAL_GPIO_TogglePin(LED_R_GPIO_Port,LED_R_Pin); HAL_UART_Transmit(\u0026amp;huart1,\u0026#34;R\u0026#34;, sizeof(\u0026#34;R\u0026#34;)-1, 100); sta++; if(sta==4){ HAL_TIM_PWM_Start(\u0026amp;htim2, TIM_CHANNEL_2); } } } void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if(sta==1){ set_pwm_param(htim2, TIM_CHANNEL_2, 1000, 50); } else if(sta==2) { set_pwm_param(htim2, TIM_CHANNEL_2, 1000, 20); } else if(sta==3){ // HAL_TIM_PWM_Stop(\u0026amp;htim2, TIM_CHANNEL_2); HAL_UART_Transmit(\u0026amp;huart1,\u0026#34;3\u0026#34;, sizeof(\u0026#34;3\u0026#34;)-1, 100); } else if(sta==4){ // set_pwm_param(htim2, TIM_CHANNEL_2, 1000, 40); } } å¤§æ¦‚å°±æ˜¯è¿™ä¹ˆä¸ªæ„æ€ä¹Ÿæ²¡ä»”ç»†çœ‹HALå¼€å‘çš„æ–‡æ¡£ å°±è™¾æ‘¸æˆ‘è±†\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321152821082.png","permalink":"https://clingyang.github.io/p/hal_pwm%E9%85%8D%E7%BD%AE%E5%8D%A0%E7%A9%BA%E6%AF%94%E9%A2%91%E7%8E%872%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6%E6%80%9D%E8%B7%AF/","title":"HAL_PWMé…ç½®å ç©ºæ¯”é¢‘ç‡2æŒ‰é”®æ§åˆ¶æ€è·¯"},{"content":" MultiButton æ˜¯ä¸€ä¸ªå¼€æºçš„è½»é‡çš„æŒ‰é”®åˆ¤æ–­çš„å‡½æ•° å¦‚ä¸‹ä½¿è¯¥å‡½æ•°çš„å¼€æºé“¾æ¥ï¼š\n0x1abin/MultiButton: Button driver for embedded system (github.com)\nå¦‚ä½•ä½¿ç”¨è¿™ä¸ªåº“é‡Œé¢å·²ç»æ˜¯å†™çš„å¾ˆæ¸…æ¥šäº†\näº‹ä»¶ è¯´æ˜ PRESS_DOWN æŒ‰é”®æŒ‰ä¸‹ï¼Œæ¯æ¬¡æŒ‰ä¸‹éƒ½è§¦å‘ PRESS_UP æŒ‰é”®å¼¹èµ·ï¼Œæ¯æ¬¡æ¾å¼€éƒ½è§¦å‘ PRESS_REPEAT é‡å¤æŒ‰ä¸‹è§¦å‘ï¼Œå˜é‡repeatè®¡æ•°è¿å‡»æ¬¡æ•° SINGLE_CLICK å•å‡»æŒ‰é”®äº‹ä»¶ DOUBLE_CLICK åŒå‡»æŒ‰é”®äº‹ä»¶ LONG_PRESS_START è¾¾åˆ°é•¿æŒ‰æ—¶é—´é˜ˆå€¼æ—¶è§¦å‘ä¸€æ¬¡ LONG_PRESS_HOLD é•¿æŒ‰æœŸé—´ä¸€ç›´è§¦å‘ æœ¬äººè‡ªå·±å†å°è£…äº†ä¸€éä¸¤ä¸ªæŒ‰é”®\nbutton.cæ–‡ä»¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026#34;button.h\u0026#34; enum Button_IDs { start_key, Estop_key, }; struct Button btn1; struct Button btn2; static void BTN1_PRESS_DOWN_Handler(void *btn) { printf(\u0026#34;BTN1_PRESS_DOWN_Handler\\r\\n\u0026#34;); } static void BTN2_PRESS_DOWN_Handler(void *btn) { printf(\u0026#34;BTN2_PRESS_DOWN_Handler\\r\\n\u0026#34;); } static uint8_t read_button_GPIO(uint8_t button_id) { // you can share the GPIO read function with multiple Buttons switch (button_id) { case start_key: return HAL_GPIO_ReadPin(start_GPIO_Port, start_Pin); case Estop_key: return HAL_GPIO_ReadPin(Estop_GPIO_Port, Estop_Pin); default: return 0; } } // æŒ‰é”®æ³¨å†Œ void button_register() { // æŒ‰é”®åˆå§‹åŒ– button_init(\u0026amp;btn1, read_button_GPIO, 0, start_key); button_init(\u0026amp;btn2, read_button_GPIO, 0, Estop_key); // ç»‘å®šåˆ°å›è°ƒå‡½æ•° button_attach(\u0026amp;btn1, SINGLE_CLICK, BTN1_PRESS_DOWN_Handler); button_attach(\u0026amp;btn2, SINGLE_CLICK, BTN2_PRESS_DOWN_Handler); button_start(\u0026amp;btn1); button_start(\u0026amp;btn2); } button.hæ–‡ä»¶ 1 2 3 4 5 6 7 8 9 10 #ifndef __BUTTON_H_ #define __BUTTON_H_ #include \u0026#34;global.h\u0026#34; #include \u0026#34;multi_button.h\u0026#34; void button_register(); #endif å€¼å¾—æ³¨æ„çš„æ˜¯æ³¨æ„æºå‡½æ•°é‡Œé¢æœ‰ä¸ªç±»ä¼¼â€œå¿ƒè·³â€œçš„ä¸œè¥¿ 1 void button_ticks(void); ä½ å¾—5msæ‰§è¡Œä¸€ä¸‹ å¯ä»¥æ”¾whileä¸»å¾ªç¯é‡Œé¢\n1 2 3 4 5 while (1) { button_ticks(); HAL_Delay(5); } ä¹Ÿå¯ä»¥æ”¾åœ¨å®šæ—¶å™¨ä¸­æ–­é‡Œé¢\n1 2 3 4 5 6 7 8 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { //5ms if (htim-\u0026gt;Instance == TIM7) // { button_ticks(); } } è¿˜æœ‰ä¸€ç‚¹å°±æ˜¯éœ€è¦å†æ‰§è¡Œä¸»å‡½æ•°ä¹‹å‰æŠŠæŒ‰é”®æ³¨å†Œä»€ä¹ˆå‡½æ•°åˆå§‹åŒ–ä¸€é\n1 button_init(\u0026amp;btn1, read_button_GPIO, 0, start_key); ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯æŒ‰é”®é«˜ç”µå¹³è¿˜æ˜¯ä½ç”µå¹³æœ‰æ•ˆ\nå¤šä¸ªæŒ‰é”®çš„è¯ æ¨èä½¿ç”¨ä¸‹é¢çš„æ–¹å¼ æŠŠå›è°ƒåˆ¤æ–­æ”¾åœ¨ä¸€ä¸ªå‡½æ•°é‡Œé¢\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026#34;multi_button.h\u0026#34; #include \u0026#34;bsp_key.h\u0026#34; #include \u0026#34;My_button.h\u0026#34; enum Button_IDs { btn1_id, btn2_id, BUTTONS_NUM, }; struct Button btn1; struct Button btn2; static uint8_t read_button_GPIO(uint8_t button_id) { switch (button_id) { case btn1_id: return HAL_GPIO_ReadPin(Key1_GPIO_PORT, Key1_GPIO_PIN); case btn2_id: return HAL_GPIO_ReadPin(Key2_GPIO_PORT, Key2_GPIO_PIN); default: return 0; } } static void Buttons_Callback(void *button) { PressEvent btn_event_val; btn_event_val = get_button_event((struct Button *)button); // FAN_DW æŒ‰é”® è§¦å‘äº‹ä»¶å¤„ç† if ((struct Button *)button == \u0026amp;btn1) { if (btn_event_val == SINGLE_CLICK) { } } // UV_KEY æŒ‰é”® è§¦å‘äº‹ä»¶ else if ((struct Button *)button == \u0026amp;btn2) { if (btn_event_val == SINGLE_CLICK) { } } } void My_button_init_attach_start(void) { button_init(\u0026amp;btn1, read_button_GPIO, 0, btn1_id); button_init(\u0026amp;btn2, read_button_GPIO, 0, btn2_id); button_attach(\u0026amp;btn1, SINGLE_CLICK, Buttons_Callback); button_attach(\u0026amp;btn1, LONG_PRESS_HOLD, Buttons_Callback); button_attach(\u0026amp;btn2, SINGLE_CLICK, Buttons_Callback); button_attach(\u0026amp;btn2, LONG_PRESS_HOLD, Buttons_Callback); button_start(\u0026amp;btn1); button_start(\u0026amp;btn2); } ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321151134842.png","permalink":"https://clingyang.github.io/p/hal_%E6%8C%89%E9%94%AE-multibutton%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/","title":"HAL_æŒ‰é”®-MultiButtonä½¿ç”¨è®°å½•"},{"content":"ä¸‹è½½é“¾æ¥ï¼š Automatic USB driver installer for FTDI and LibUSB drivers (visualgdb.com) 2. SEGGER - The Embedded Experts - Downloads - J-Link / J-Trace\nå®‰è£…å®Œæˆå ä¿®æ”¹jlinkçš„é…ç½®æ–‡ä»¶ ç„¶åä¿®æ”¹ä½ çš„ä¸‹è½½å™¨ä¸ºjlink çƒ§å½•ä½ çš„é¡¹ç›® ç»å¯¹ä¼šå‡ºç°ä¸‹é¢çš„é—®é¢˜ é‚£ä¹ˆæ‰“å¼€ä¸‹è½½çš„ç¬¬ä¸€ä¸ªè½¯ä»¶ ï¼ˆç‚¹åˆ°è¿™ä¸ªjlinkå³é”®ï¼‰å¦‚ä¸‹æ“ä½œï¼š ä¿®æ”¹åå¦‚ä¸‹è¡¨ç¤ºä¿®æ”¹å®Œæˆ ä¸‹è½½æˆåŠŸçš„æ ·å­ï¼š å‚è€ƒæ–‡ç«  è§£å†³openocdæ— æ³•è¯†åˆ«jlinkçš„é—®é¢˜LIBUSB_ERROR_NOT_SUPPORTED_no emulators connected via usb-CSDNåšå®¢ OpenOCD-Jlinké…ç½®æ–¹æ³• ","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321153322108.png","permalink":"https://clingyang.github.io/p/vscode_openocd_jlink-%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/","title":"VSCODE_openocd_Jlink çš„é…ç½®ç¬”è®°"},{"content":"1.å‡†å¤‡å·¥ä½œ 1.ä¸‹è½½å¹¶å®‰è£…VSCODE åœ¨ç™¾åº¦ä¸Šæœç´¢vscodeè®°ä½ä¸€å®šè¦æ˜¯å®˜æ–¹çš„ ä¸ç„¶ä½ è‡ªå·±å°±æ˜¯åœ¨ç»™è‡ªå·±ä¸‹æ¯’2345å…¨æ¥äº†\næ‰“çº¢åœˆä¸€å®šè¦æœ‰ä¸ç„¶å°±æ˜¯åœ¨åƒåœ¾ç½‘ç«™ä¸Šä¸‹çš„ VSCodeä¸‹è½½é“¾æ¥\né€‰ä¸€ä¸ªé€‚åˆä½ çš„ å®‰è£…æ­£å¸¸æµç¨‹èµ°å°±è¡Œä¸å†èµ˜è¿° VScodeå®‰è£…\n2.å®‰è£…å¼€å‘æ’ä»¶ å®‰è£…å®Œæˆåé…ç½®ä¸€ä¸‹å¼€å‘ç¯å¢ƒ å‚è€ƒé“¾æ¥ï¼š VScode+EIDEè°ƒè¯•STM32 æ¨èè§†é¢‘æ•™ç¨‹ï¼š\nä¸è¿‡æœ¬äººå’Œä¸Šé¢çš„é…ç½®æœ‰ç‚¹å‡ºå…¥\næˆ‘æ˜¯å®‰è£…å®ŒEIDE å’Œ Cortex-Debug æ’ä»¶é‡Œé¢ä¸‹è½½é…ç½®çš„ç¯å¢ƒï¼š\nç¬¬ä¸€æ­¥ï¼š æŒ‰ç…§å¦‚å›¾çš„é¡ºåºå®‰è£…é…ç½®ç¯å¢ƒ æˆ‘ç”¨çš„æ˜¯GCCçš„å·¥å…·é“¾å…¶å®ä¹Ÿå¯ä»¥æŠŠkeilçš„ç¯å¢ƒé…ç½®åœ¨é‡Œé¢è¿™ä¸ªç½‘ä¸Šä¹Ÿæœ‰å¥½å¤šæ•™ç¨‹å¤§åŒå°å¼‚ ç¬¬äºŒæ­¥ï¼š åˆ›å»ºç¤ºä¾‹å·¥ç¨‹\nä¸Šé¢æœ‰å››ç§åˆ›å»ºæ–¹å¼ æˆ‘ä¸€èˆ¬å›¾ç®€å• æ¯æ¬¡ä¸€ä¸ªå·¥ç¨‹å°±ç”¨çš„æ˜¯ç¬¬å››ç§ åœ¨githubä¸Šæ‹‰å–ä¸€ä¸ªæ¨¡æ¿\nåˆ›å»ºåæ‰“å¼€å·¥ä½œåŒº\nå·¦ä¸Šè§’æœ‰ç¼–è¯‘ æ¸…é™¤ å’Œ ä¸‹è½½ æˆ‘ä»¬å…ˆç¼–è¯‘\nå¯ä»¥çœ‹è§é€Ÿåº¦æ¯”keil å¿«å¾ˆå¤š ç„¶åå°±å¯ä»¥ä¸‹è½½æµ‹è¯•ä¸€ä¸‹äº† è¿™è¾¹éœ€è¦æ ¹æ®è‡ªå·±çš„å¼€å‘æ¿é€‰æ‹©ledçš„å¼•è„š æˆ‘ä»¬çš„å¼•è„šæ˜¯PC13 ç„¶åå°±æ˜¯ä¸‹è½½äº†ä¸‹è½½ä¹‹å‰æˆ‘ä»¬æŠŠçƒ§å…¥å·¥å…·æ¢æˆopenOCD\nç„¶åä¸‹è½½å°±èƒ½çœ‹è§ç°è±¡äº†\nè°ƒè¯• Debug è¿™ä¸ªæ“ä½œå°±çœ‹ä¸‹é¢çš„æ­¥éª¤äº†\næ·»åŠ \n1 2 3 4 \u0026#34;liveWatch\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;samplesPerSecond\u0026#34;: 1 } æŠŠè¦è§‚å¯Ÿçš„å˜é‡åŠ è¿›å» åˆ·æ–°æ˜¯1ç§’ä¸€æ¬¡ æœ€ä½äº†damn ç„¶åå¯åŠ¨å°±èƒ½çœ‹è§å˜é‡å˜åŒ–äº† åˆ·æ–°æ˜¯1ç§’ä¸€æ¬¡ æœ€ä½äº†damn ç„¶åå¯åŠ¨å°±èƒ½çœ‹è§å˜é‡å˜åŒ–äº† ======================= #######2024620######### è¿™ä¸ªdebug æœ‰ä¸ªä¸å¥½çš„ç‚¹ å°±æ˜¯æ¯ç§’è¯»ä¸€æ¬¡ è€Œå´æ•°ç»„ä¸èƒ½è¯»å¤š æ¯”å¦‚buf[256]çš„è¯ ä½ ä¸èƒ½ç›´æ¥æ·»åŠ buff å»è§‚å¯Ÿ ä½ åªè¦æ·»åŠ ä½ æƒ³è¦è§‚å¯Ÿçš„å“ªä¸€ä¸ª buff[2] æˆ–è€…å…¶å®ƒ\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321141258785.png","permalink":"https://clingyang.github.io/p/vscode%E5%BC%80%E5%8F%91stm32%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"VScodeå¼€å‘stm32ç¯å¢ƒæ­å»º"},{"content":"è¿™æ¬¡æˆ‘ä»¬æ¥å®ç°ç”¨æŒ‰é”®æ§åˆ¶led ä¸å¸¦ä¸­æ–­çš„æ–¹å¼ å½“ç„¶å®ä¾‹æ¥æºç½‘ç»œ åŠ ä¸Šè‡ªå·±æ•´åˆ å…ˆç†Ÿæ‚‰æµç¨‹ 0.æ·»åŠ ä¸€ä¸ªè‡ªå·±å†™çš„é©±åŠ¨åº“æ–‡ä»¶ ä¸ºä»€ä¹ˆæ·»åŠ  ç¬”è€…æƒ³çš„æ˜¯ä¸€ä¸ªé¡¹ç›®å·¥ç¨‹å¸Œæœ›èƒ½é€‚åº”å¾ˆå¤šä¸ªåº”ç”¨åœºæ™¯éœ€è¦ä»€ä¹ˆç›´æ¥åœ¨é‡Œé¢è°ƒç”¨åˆ†è£…å¥½çš„å‡½æ•°å°±è¡Œ\n1.å¦‚ä½•æ·»åŠ æ–‡ä»¶ä»¥åŠç¼–å†™é©±åŠ¨åç¼–è¯‘ ç”¨ä¹‹å‰æ¡ˆä¾‹è®²åˆ°çš„å®ä¾‹å·¥ç¨‹æ·»åŠ ä¸€ä¸ªHardwareæ–‡ä»¶å¤¹ ï¼š\n1.å°è£…LEDåº“å‡½æ•° Led.C å¼•è„šæŒ‰éœ€é…ç½®\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026#34;stm32f10x.h\u0026#34; // Device header // LED åˆå§‹åŒ– void LED_Init(void){ GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC,\u0026amp;GPIO_InitStruct); // åˆå§‹åŒ– ç½®1 GPIO_SetBits(GPIOC,GPIO_Pin_13); } void LED_ON(void){ GPIO_ResetBits(GPIOC,GPIO_Pin_13); } void LED_OFF(void){ GPIO_SetBits(GPIOC,GPIO_Pin_13); } // é«˜ä½ç”µå¹³åè½¬ void LED_Turn(void) { if(GPIO_ReadOutputDataBit(GPIOC,GPIO_Pin_13)==0) { GPIO_SetBits(GPIOC,GPIO_Pin_13); } else { GPIO_ResetBits(GPIOC,GPIO_Pin_13); } } Led.h\n1 2 3 4 5 6 7 8 9 #ifndef __LED_H #define __LED_H void LED_Init(void); // led å¼•è„šåˆå§‹åŒ– void LED_ON(void); // led å¼€ void LED_OFF(void); // led å…³ void LED_Turn(void); // led åè½¬ #endif 2.å°è£…Keyå‡½æ•°åº“ å’Œä¸Šæ­¥ç›¸åŒ Key.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; // åˆå§‹åŒ–æ¥åœ°æŒ‰é”® void Key_Init(void){ GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13|GPIO_Pin_12; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB,\u0026amp;GPIO_InitStruct); } uint8_t Key_GetNum(void){ uint8_t Key_Num = 0; if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)== 0){ Delay_ms(20); while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_13)== 0); Delay_ms(20); Key_Num = 1;\t} if(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)== 0){ Delay_ms(20); while(GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_12)== 0); Delay_ms(20); Key_Num = 2; } return Key_Num; } key.h\n1 2 3 4 5 6 7 8 9 #ifndef __KEY_H #define __KEY_H void Key_Init(void); uint8_t Key_GetNum(void); #endif ç¼–å†™åŠŸèƒ½éœ€æ±‚ main.c\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;stm32f10x.h\u0026#34; // Device header #include \u0026#34;Delay.h\u0026#34; #include \u0026#34;LED.h\u0026#34; #include \u0026#34;Key.h\u0026#34; uint8_t KeyNum; uint8_t StaNum=0; int main(void) { LED_Init(); Key_Init(); while (1) { KeyNum = Key_GetNum(); if (KeyNum == 1) { LED_Turn(); } } } ç°è±¡å°±æ˜¯æŒ‰ä¸€ä¸‹æŒ‰é”®led pc13çŠ¶æ€åè½¬ä¸€æ¬¡ ç¼–è¯‘ä¸‹è½½çœ‹ç°è±¡\nå°±æ˜¯æŒ‰ä¸€ä¸‹æŒ‰é”®led pc13çŠ¶æ€åè½¬ä¸€æ¬¡\nç¼–è¯‘ä¸‹è½½çœ‹ç°è±¡\nè¿™é‡Œçš„é¡¹ç›®é…ç½®ä¸è¦å‡ºé”™\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321144847871.png","permalink":"https://clingyang.github.io/p/%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6led/","title":"æŒ‰é”®æ§åˆ¶led"},{"content":"æ‰€éœ€ä»£ç  å‚è€ƒæ¥æºç½‘ç»œ å»¶æ—¶å‡½æ•°å‚è€ƒï¼š\nDelay.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026#34;stm32f10x.h\u0026#34; /** * @brief å¾®ç§’çº§å»¶æ—¶ * @param xus å»¶æ—¶æ—¶é•¿ï¼ŒèŒƒå›´ï¼š0~233015 * @retval æ—  */ void Delay_us(uint32_t xus) { SysTick-\u0026gt;LOAD = 72 * xus;\t//è®¾ç½®å®šæ—¶å™¨é‡è£…å€¼ SysTick-\u0026gt;VAL = 0x00;\t//æ¸…ç©ºå½“å‰è®¡æ•°å€¼ SysTick-\u0026gt;CTRL = 0x00000005;\t//è®¾ç½®æ—¶é’Ÿæºä¸ºHCLKï¼Œå¯åŠ¨å®šæ—¶å™¨ while(!(SysTick-\u0026gt;CTRL \u0026amp; 0x00010000));\t//ç­‰å¾…è®¡æ•°åˆ°0 SysTick-\u0026gt;CTRL = 0x00000004;\t//å…³é—­å®šæ—¶å™¨ } /** * @brief æ¯«ç§’çº§å»¶æ—¶ * @param xms å»¶æ—¶æ—¶é•¿ï¼ŒèŒƒå›´ï¼š0~4294967295 * @retval æ—  */ void Delay_ms(uint32_t xms) { while(xms--) { Delay_us(1000); } } /** * @brief ç§’çº§å»¶æ—¶ * @param xs å»¶æ—¶æ—¶é•¿ï¼ŒèŒƒå›´ï¼š0~4294967295 * @retval æ—  */ void Delay_s(uint32_t xs) { while(xs--) { Delay_ms(1000); } } Delay.h 1 2 3 4 5 6 7 #ifndef __DELAY_H #define __DELAY_H void Delay_us(uint32_t us); void Delay_ms(uint32_t ms); void Delay_s(uint32_t s); #endif LED.c ç”¨çš„PINè„šæ˜¯PC13 å¯æ ¹æ®è‡ªå·±çš„æƒ…å†µä¿®æ”¹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026#34;stm32f10x.h\u0026#34; // Device header // LED åˆå§‹åŒ– void LED_Init(void){ GPIO_InitTypeDef GPIO_InitStruct; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitStruct.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStruct.GPIO_Pin = GPIO_Pin_13; GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC,\u0026amp;GPIO_InitStruct); // åˆå§‹åŒ–ç½®1 GPIO_SetBits(GPIOC,GPIO_Pin_13); } void LED1_ON(void){ GPIO_ResetBits(GPIOC,GPIO_Pin_13); } void LED1_OFF(void){ GPIO_SetBits(GPIOC,GPIO_Pin_13); } // é«˜ä½ç”µå¹³åè½¬ void LED1_Turn(void) { if(GPIO_ReadOutputDataBit(GPIOC,GPIO_Pin_13)==0) { GPIO_SetBits(GPIOC,GPIO_Pin_13); } else { GPIO_ResetBits(GPIOC,GPIO_Pin_13); } } LED.h 1 2 3 4 5 6 7 8 9 #ifndef __LED_H #define __LED_H void LED_Init(void); // LEDåˆå§‹åŒ– void LED1_ON(void); // void LED1_OFF(void); void LED1_Turn(void); #endif main.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026#34;stm32f10x.h\u0026#34; #include \u0026#34;LED.h\u0026#34; #include \u0026#34;Delay.h\u0026#34; int main(void) { LED_Init(); // åˆå§‹LED while (1) { LED1_OFF(); Delay_ms(500); LED1_ON(); Delay_ms(500); } } ç¼–è¯‘ ä¸‹è½½ äº®äº† å‚è€ƒé“¾æ¥1ï¼š\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321144539906.png","permalink":"https://clingyang.github.io/p/%E7%82%B9%E4%BA%AE%E4%B8%80%E4%B8%AAled/","title":"ç‚¹äº®ä¸€ä¸ªled"},{"content":"å‚è€ƒæ¥æº1 è¿™æ˜¯å¦ä¸€ç§æ–¹æ³•\nåœ¨printf é‡å®šå‘çš„åŸºç¡€ä¸ŠåŠ ä¸Š ä¸€å¥\nsetbuf(stdout,NULL);\nå‚è€ƒæ¥æº2 è‡ªå·±å†™çš„ç¬”è®°å•¦\n","date":"2024-11-21T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250321140651747.png","permalink":"https://clingyang.github.io/p/%E5%85%B3%E4%BA%8Eclion%E5%BC%80%E5%8F%91stm32printf%E9%87%8D%E5%AE%9A%E5%90%91%E9%97%AE%E9%A2%98%E7%AE%80%E5%8D%95%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%96%B9%E6%B3%95/","title":"å…³äºClionå¼€å‘stm32printfé‡å®šå‘é—®é¢˜ç®€å•è§£å†³é—®é¢˜æ–¹æ³•"},{"content":" ä¸»è¦åˆ©ç”¨çš„æ˜¯vscodeé‡Œé¢stm32forvscodeçš„æ’ä»¶ ç¬¬ä¸€æ­¥å°±æ˜¯åˆ›å»ºcubmaxçš„å·¥ç¨‹ RCC è°ƒè¯•æ–¹å¼ å’Œ æ—¶åŸº è¿™é‡ŒDebug ä¸æ•´å¥½ è¿™ä¸ªæ¿å­å°±ä¼šå˜ç – è¦ç”¨çº¿åˆ·äº†\né€‰æ‹©FREERTOS\né€‰æ‹©æœ€å¤§é¢‘ç‡ .c å’Œ .h æ–‡ä»¶åˆ†å¼€ç”Ÿæˆ ç”Ÿæˆï¼ï¼(åŸç¥å¯åŠ¨) å…³äºè¿™ä¸ªæ¡†æ¶çš„å»ºç«‹ æˆ‘é€‰æ‹©å¦‚ä¸‹è¿™æ · åº”ç”¨å’Œé©±åŠ¨ï¼š\nä½ æ–°å»ºäº†ä¸¤ä¸ªæ–‡ä»¶å¤¹æ‰€ä»¥éœ€è¦å†makefileæ–‡ä»¶æ·»åŠ è¿›æ¥\nè¿™ä¸ªæ’ä»¶å¯ä»¥å¸®ä½ æ·»åŠ ä½†æ˜¯éœ€è¦ä½ è®¾ç½®ä¸€ä¸‹\nDrivers å±‚é¢ .c æ–‡ä»¶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026#34;led_driver.h\u0026#34; /// @brief å…¨å½©ç¯åˆå§‹åŒ– /// @param void led_init(void) { HAL_GPIO_WritePin(RGB_PORT_R, RGB_PIN_R, GPIO_PIN_SET); HAL_GPIO_WritePin(RGB_PORT_G, RGB_PIN_G, GPIO_PIN_SET); HAL_GPIO_WritePin(RGB_PORT_B, RGB_PIN_B, GPIO_PIN_SET); } /// @brief è®¾ç½®ç¯çš„é¢œè‰² /// @param red /// @param green /// @param blue void color_led_set(uint8_t red, uint8_t green, uint8_t blue) { //çº¢ç¯ï¼š HAL_GPIO_WritePin(RGB_PORT_R, RGB_PIN_R, (GPIO_PinState)!red); //ç»¿ç¯ï¼š HAL_GPIO_WritePin(RGB_PORT_G, RGB_PIN_G, (GPIO_PinState)!green); //è“ç¯ï¼š HAL_GPIO_WritePin(RGB_PORT_B, RGB_PIN_B, (GPIO_PinState)!blue); } .hæ–‡ä»¶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #ifndef __LED_DRIVER_H__ #define __LED_DRIVER_H__ #include \u0026#34;main.h\u0026#34; #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif #define RGB_PORT_R GPIOB #define RGB_PORT_G GPIOB #define RGB_PORT_B GPIOB #define RGB_PIN_R GPIO_PIN_5 #define RGB_PIN_G GPIO_PIN_0 #define RGB_PIN_B GPIO_PIN_1 void color_led_set(uint8_t red, uint8_t green, uint8_t blue); void led_init(void); #ifdef __cplusplus } #endif #endif /* __LED_DRIVER_H__ */ appåº”ç”¨å±‚é¢ .h æ–‡ä»¶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #ifndef MAIN_INCLUDE_APPLICATION_H_ #define MAIN_INCLUDE_APPLICATION_H_ #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif /*Driver Include*/ #include \u0026#34;led_driver.h\u0026#34; #include \u0026#34;beep_driver.h\u0026#34; #include \u0026#34;my_printf.h\u0026#34; /*User lib Include*/ /*pnblic Include*/ #include \u0026#34;FreeRTOS.h\u0026#34; #include \u0026#34;task.h\u0026#34; #include \u0026#34;main.h\u0026#34; #include \u0026#34;cmsis_os.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; // sprintf #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; /********************************************************API********************************************************/ void AppTaskCreate(void); /*LED app*/ void color_led_task_fun(void *argument); /* æµ‹è¯•ä»»åŠ¡ */ void test_task_fun(void *arg); #ifdef __cplusplus } #endif #endif /* MAIN_INCLUDE_APPLICATION_H_ */ .c åˆ›å»ºä»»åŠ¡å‡½æ•°æ–‡ä»¶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include \u0026#34;Application.h\u0026#34; /**************************** ä»»åŠ¡å¥æŸ„ ********************************/ /* * ä»»åŠ¡å¥æŸ„æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œç”¨äºæŒ‡å‘ä¸€ä¸ªä»»åŠ¡ï¼Œå½“ä»»åŠ¡åˆ›å»ºå¥½ä¹‹åï¼Œå®ƒå°±å…·æœ‰äº†ä¸€ä¸ªä»»åŠ¡å¥æŸ„ * ä»¥åæˆ‘ä»¬è¦æƒ³æ“ä½œè¿™ä¸ªä»»åŠ¡éƒ½éœ€è¦é€šè¿‡è¿™ä¸ªä»»åŠ¡å¥æŸ„ï¼Œå¦‚æœæ˜¯è‡ªèº«çš„ä»»åŠ¡æ“ä½œè‡ªå·±ï¼Œé‚£ä¹ˆ * è¿™ä¸ªå¥æŸ„å¯ä»¥ä¸ºNULLã€‚ */ static TaskHandle_t COLOR_LED_Handle = NULL; /* LEDä»»åŠ¡å¥æŸ„ */ static TaskHandle_t TEST_TASK_Handle = NULL; /* ä»»åŠ¡å¥æŸ„ */ /********************************** å†…æ ¸å¯¹è±¡å¥æŸ„ *********************************/ /* * ä¿¡å·é‡ï¼Œæ¶ˆæ¯é˜Ÿåˆ—ï¼Œäº‹ä»¶æ ‡å¿—ç»„ï¼Œè½¯ä»¶å®šæ—¶å™¨è¿™äº›éƒ½å±äºå†…æ ¸çš„å¯¹è±¡ï¼Œè¦æƒ³ä½¿ç”¨è¿™äº›å†…æ ¸ * å¯¹è±¡ï¼Œå¿…é¡»å…ˆåˆ›å»ºï¼Œåˆ›å»ºæˆåŠŸä¹‹åä¼šè¿”å›ä¸€ä¸ªç›¸åº”çš„å¥æŸ„ã€‚å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œåç»­æˆ‘ * ä»¬å°±å¯ä»¥é€šè¿‡è¿™ä¸ªå¥æŸ„æ“ä½œè¿™äº›å†…æ ¸å¯¹è±¡ã€‚ * * å†…æ ¸å¯¹è±¡è¯´ç™½äº†å°±æ˜¯ä¸€ç§å…¨å±€çš„æ•°æ®ç»“æ„ï¼Œé€šè¿‡è¿™äº›æ•°æ®ç»“æ„æˆ‘ä»¬å¯ä»¥å®ç°ä»»åŠ¡é—´çš„é€šä¿¡ï¼Œ * ä»»åŠ¡é—´çš„äº‹ä»¶åŒæ­¥ç­‰å„ç§åŠŸèƒ½ã€‚è‡³äºè¿™äº›åŠŸèƒ½çš„å®ç°æˆ‘ä»¬æ˜¯é€šè¿‡è°ƒç”¨è¿™äº›å†…æ ¸å¯¹è±¡çš„å‡½æ•° * æ¥å®Œæˆçš„ * */ /******************************* å…¨å±€å˜é‡å£°æ˜ ************************************/ /* * å½“æˆ‘ä»¬åœ¨å†™åº”ç”¨ç¨‹åºçš„æ—¶å€™ï¼Œå¯èƒ½éœ€è¦ç”¨åˆ°ä¸€äº›å…¨å±€å˜é‡ã€‚ */ /* ************************************************************************* * å‡½æ•°å£°æ˜ ************************************************************************* */ void app_main_delay_ms(uint16_t ms); /* ************************************************************************* ************************************************************************* */ /// @brief åˆ›å»ºä»»åŠ¡ /// @param void AppTaskCreate(void) { taskENTER_CRITICAL(); // è¿›å…¥ä¸´ç•ŒåŒº BaseType_t xReturn = pdPASS; /* å®šä¹‰ä¸€ä¸ªåˆ›å»ºä¿¡æ¯è¿”å›å€¼ï¼Œé»˜è®¤ä¸ºpdPASS */ uint32_t count = 0; /* åˆ›å»ºTest_Taskä»»åŠ¡ */ xReturn = xTaskCreate((TaskFunction_t)color_led_task_fun, /* ä»»åŠ¡å…¥å£å‡½æ•° */ (const char *)\u0026#34;COLOR_LED_TASK\u0026#34;, /* ä»»åŠ¡åå­— */ (uint16_t)256, /* ä»»åŠ¡æ ˆå¤§å° */ (void *)NULL, /* ä»»åŠ¡å…¥å£å‡½æ•°å‚æ•° */ (UBaseType_t)osPriorityNormal, /* ä»»åŠ¡çš„ä¼˜å…ˆçº§ */ (TaskHandle_t *)\u0026amp;COLOR_LED_Handle); /* ä»»åŠ¡æ§åˆ¶å—æŒ‡é’ˆ */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;COLOR_LED_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); xReturn = xTaskCreate((TaskFunction_t)test_task_fun, /* ä»»åŠ¡å…¥å£å‡½æ•° */ (const char *)\u0026#34;TEST_TASK\u0026#34;, /* ä»»åŠ¡åå­— */ (uint16_t)256, /* ä»»åŠ¡æ ˆå¤§å° */ (void *)NULL, /* ä»»åŠ¡å…¥å£å‡½æ•°å‚æ•° */ (UBaseType_t)osPriorityNormal, /* ä»»åŠ¡çš„ä¼˜å…ˆçº§ */ (TaskHandle_t *)\u0026amp;TEST_TASK_Handle); /* ä»»åŠ¡æ§åˆ¶å—æŒ‡é’ˆ */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;TEST_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); return; error: UART1_Printf(\u0026#34;App_Task_Create[error]:Task Create fail,system exception\\n\u0026#34;); while (1) { UART1_Printf(\u0026#34;error count:%d\\n\u0026#34;, (int)count++); app_main_delay_ms(1000); } taskEXIT_CRITICAL(); // é€€å‡ºä¸´ç•ŒåŒº } void app_main_delay_ms(uint16_t ms) { vTaskDelay(pdMS_TO_TICKS(ms)); } .c ä»»åŠ¡åˆ†ç¦»æ–‡ä»¶\nå…³äºå¦‚ä½•åº”ç”¨ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026#34;Application.h\u0026#34; /// @brief color_led_task_fun RGB ç¯çš„åº”ç”¨ /// @param arg void color_led_task_fun(void *arg) { while (true) { /* color_ledçš„åº”ç”¨ */ //çº¢ç¯äº®ï¼š color_led_set(1, 0, 0); os_Delay(1000); //ç»¿ç¯äº®ï¼š color_led_set(0, 1, 0); os_Delay(1000); //è“ç¯äº®ï¼š color_led_set(0, 0, 1); os_Delay(1000); //é»„ç¯äº®ï¼š color_led_set(1, 1, 0); os_Delay(1000); //ç´«ç¯äº®ï¼š color_led_set(1, 0, 1); os_Delay(1000); //ç²‰ç¯äº® color_led_set(0, 1, 1); os_Delay(1000); } } å…³äºå¦‚ä½•åµŒå…¥æ¡†æ¶ ä½ åªéœ€è¦ä»¥ä¸‹ä¸¤æ­¥å°±è¡Œ ç¬¬äºŒæ­¥ ","date":"2024-11-20T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320151456223.png","permalink":"https://clingyang.github.io/p/hal_freertos%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%951/","title":"HAL_Freertosçš„ä½¿ç”¨è®°å½•1"},{"content":"ç¬¬ä¸€æ­¥å‡†å¤‡ç¯å¢ƒ STM32CubeMX VSCODE MinGW OpenOcd arm-none-eabi-gcc ç„¶åæŠŠä¸Šé¢ä¸‹è½½çš„è½¯ä»¶ 3 4 5 bin æ–‡ä»¶ç›®å½•æ·»åŠ åˆ°ç³»ç»Ÿå˜é‡\nvscode æ’ä»¶æ’ä»¶é…ç½® 1. ä¸‹è½½è¿™ä¸ªæ’ä»¶ stm32-for-vscode é…ç½®3 4 5 çš„ æ–‡ä»¶åœ°å€\næ–°å»ºä¸€ä¸ªcubemxçš„å·¥ç¨‹ åŒå‡»åæ¥åˆ°è¿™é‡Œ é…ç½®å¼•è„š PC13 putout è®¾ç½®ç”Ÿæˆé€‰é¡¹ ç‚¹ç¯ å†™å…¥åè½¬ åœ¨ /* USER CODE BEGIN 3 */å’Œ /* USER CODE END 3 */ ä¹‹é—´ å¦‚å›¾æ‰€ç¤ºï¼š\nbuild å’Œ flsah build flash ","date":"2024-11-20T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320175246956.png","permalink":"https://clingyang.github.io/p/stm32cubemx-vscode-gcc-makefile-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"stm32cubemx+VSCODE+GCC+makefile å¼€å‘ç¯å¢ƒæ­å»º"}]