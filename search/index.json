[{"content":"关于主任务函数 之前写到在主函数里面处理的事件也不知道有没有问题 之所以这么写是因为我觉得如果全用cubemax配置好的话下次如果换主控可能会比较麻烦 所以今天再细看一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void AppTaskCreate(void) { taskENTER_CRITICAL(); // 进入临界区 BaseType_t xReturn = pdPASS; /* 定义一个创建信息返回值，默认为pdPASS */ uint32_t count = 0; /* 创建Test_Task任务 */ xReturn = xTaskCreate((TaskFunction_t)color_led_task_fun, /* 任务入口函数 */ (const char *)\u0026#34;COLOR_LED_TASK\u0026#34;, /* 任务名字 */ (uint16_t)256, /* 任务栈大小 */ (void *)NULL, /* 任务入口函数参数 */ (UBaseType_t)osPriorityNormal, /* 任务的优先级 */ (TaskHandle_t *)\u0026amp;COLOR_LED_Handle); /* 任务控制块指针 */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;COLOR_LED_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); /* 运行占用 */ memset(pcWriteBuffer, 0, 400); vTaskList(pcWriteBuffer); // 获取内存信息 UART1_Printf(\u0026#34;\\r\\n\u0026#34;); UART1_Printf(\u0026#34;%s\\n\\r\u0026#34;, pcWriteBuffer); memset(pcWriteBuffer, 0, 400); vTaskGetRunTimeStats(pcWriteBuffer); // 获取CPU占用率信息 UART1_Printf(\u0026#34;\\r\\n\u0026#34;); UART1_Printf(\u0026#34;%s\\n\\r\u0026#34;, pcWriteBuffer); return; error: UART1_Printf(\u0026#34;App_Task_Create[error]:Task Create fail,system exception\\n\u0026#34;); while (1) { UART1_Printf(\u0026#34;error count:%d\\n\u0026#34;, (int)count++); app_main_delay_ms(1000); } taskEXIT_CRITICAL(); // 退出临界区 } 又添加了一些功能\n串口就会打印出这样的内容 当然在这之前还是要在cubemax里面打开一些东西 参考链接 全部打开变成Enable 每次配置任务就可以这样进行 修改如下 当然应用函数还是得要你自己写的 这样好处我感觉就是到时候你要是迁移芯片修改的应该不是很大\n","date":"2025-03-20T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320144944405.png","permalink":"https://clingyang.github.io/p/hal_freertos%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%952/","title":"HAL_Freertos的使用记录2"},{"content":"为了保存工作状态 长按关机后或者30分钟后断电 在这个操作前先保存状态 下次开机时直接读取保存内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026#34;Flash_baup.h\u0026#34; void SaveStateToFlash(uint8_t level, uint8_t reverse) { // 解锁 Flash HAL_FLASH_Unlock(); // 擦除 Flash 页 FLASH_EraseInitTypeDef EraseInitStruct; uint32_t PageError = 0; EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; EraseInitStruct.PageAddress = FLASH_USER_START_ADDR; EraseInitStruct.NbPages = 1; if (HAL_FLASHEx_Erase(\u0026amp;EraseInitStruct, \u0026amp;PageError) != HAL_OK) { // 错误处理 Error_Handler(); } // 写入当前档位和正反转状态 uint32_t data = (level \u0026lt;\u0026lt; 8) | reverse; if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, FLASH_USER_START_ADDR, data) != HAL_OK) { // 错误处理 Error_Handler(); } // 锁定 Flash HAL_FLASH_Lock(); } void LoadStateFromFlash(uint8_t *level, uint8_t *reverse) { uint32_t data = *(__IO uint32_t*)FLASH_USER_START_ADDR; *level = (data \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; *reverse = data \u0026amp; 0xFF; } 头文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #ifndef FLASH_BAUP_H #define FLASH_BAUP_H #include \u0026#34;stm32f0xx_hal.h\u0026#34; #include \u0026#34;main.h\u0026#34; // 定义 Flash 存储地址 #define FLASH_USER_START_ADDR ((uint32_t)0x08007000) /* Start @ of user Flash area, assuming 1KB per page and 128KB total Flash size */ // Flash 操作函数声明 void SaveStateToFlash(uint8_t level, uint8_t reverse); void LoadStateFromFlash(uint8_t *level, uint8_t *reverse); #endif // FLASH_BAUP_H 保存的是两个 uint8_t 的数据 值得注意的是我们要注意地址 存储的起始地址有讲究的 最后通过keil 也是能看到的 如果资源紧张 可以debug 一下 ","date":"2025-03-20T11:46:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145049973.png","permalink":"https://clingyang.github.io/p/hal_flash-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%AF%BB%E5%8F%96/","title":"HAL_flash 数据备份与读取"},{"content":"最近入了一个ESP32 兄弟们，这玩意还可以，买来肯定是给它点亮啊对吧 我就是点灯侠🎇 😭千万不要不接天线啊，不然你会一直找不到你的wifi 1.点灯第一步你得有IDE == Arduino 就是这个绿东西\n可是怎么下载安装呢？自己百度吧，当然你要是懒这边也给您附加了连接\nArduino 安装 \u0026mdash;这里作者认为你看连接并且你安装好了\n2023/5/2 值得注意的是 这个sdk你需要以管理员的身份去运行\nok 现在进入第二步\n2.编写点灯程序 1 2 3 4 5 6 7 8 9 10 11 12 13 const int LED = 2; void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } 烧录 一定要选串口\n上传 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 项目使用了 219045 字节，占用了 (16%) 程序存储空间。最大为 1310720 字节。 全局变量使用了16088字节，(4%)的动态内存，余留311592字节局部变量。最大为327680字节。 esptool.py v3.3 Serial port COM4 Connecting...... Chip is ESP32-D0WD-V3 (revision 3) Features: WiFi, BT, Dual Core, 240MHz, VRef calibration in efuse, Coding Scheme None Crystal is 40MHz MAC: e8:31:cd:74:1c:84 Uploading stub... Running stub... Stub running... Changing baud rate to 921600 Changed. Configuring flash size... Flash will be erased from 0x00001000 to 0x00005fff... Flash will be erased from 0x00008000 to 0x00008fff... Flash will be erased from 0x0000e000 to 0x0000ffff... Flash will be erased from 0x00010000 to 0x00045fff... Flash params set to 0x022f Compressed 18880 bytes to 12992... Writing at 0x00001000... (100 %) Wrote 18880 bytes (12992 compressed) at 0x00001000 in 0.5 seconds (effective 279.9 kbit/s)... Hash of data verified. Compressed 3072 bytes to 128... Writing at 0x00008000... (100 %) Wrote 3072 bytes (128 compressed) at 0x00008000 in 0.1 seconds (effective 350.9 kbit/s)... Hash of data verified. Compressed 8192 bytes to 47... Writing at 0x0000e000... (100 %) Wrote 8192 bytes (47 compressed) at 0x0000e000 in 0.1 seconds (effective 490.3 kbit/s)... Hash of data verified. Compressed 219440 bytes to 120828... Writing at 0x00010000... (12 %) Writing at 0x0001d956... (25 %) Writing at 0x00022fd3... (37 %) Writing at 0x00028288... (50 %) Writing at 0x0002d6ef... (62 %) Writing at 0x00035f5d... (75 %) Writing at 0x0003e042... (87 %) Writing at 0x000438e3... (100 %) Wrote 219440 bytes (120828 compressed) at 0x00010000 in 2.4 seconds (effective 722.3 kbit/s)... Hash of data verified 烧写成功看你的板子是不是在blink blink ✨✨✨✨点灯视频 ","date":"2025-03-20T11:08:09+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145935000.png","permalink":"https://clingyang.github.io/p/esp32-arduino-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"ESP32 ARDUINO 开发环境搭建"},{"content":"文章默认格式模版 推荐在模板中设置，修改 archetypes/default.md（如果没有则新建一个即可）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- date : \u0026#39;{{ .Date }}\u0026#39; draft: true title: \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; image: https://picsum.photos/800/600.webp?random={{ substr (md5 (.Date)) 4 8 }} description: 描述 summary: 文章摘要，重要！关乎ESO搜索引擎优化 categories: [ \u0026#34;hugo\u0026#34;, \u0026#34;笔记\u0026#34;, ] tags: [ \u0026#34;hugo\u0026#34;, \u0026#34;笔记\u0026#34; ] --- 这里的重点是 image 这一行，即使用了 Lorem Picsum 的接口，然后就可以得到一张随机的图片，更多详情也可前往 Lorem Picsum 了解。 之后，我们通过 hugo new 命令时，新建的文章会随机匹配一张图片\n文章的一写变量的写法 说明tags 一般是在文章内部的标题 我还要修改图片粘贴路径 在vscode 设置里面 评论区我成了 参考链接 效果可以看我评论区\n1 2 3 4 #创建新的笔记是 .\\hugo new content post/Blogname/index.md # 本地调试启动服务 .\\hugo server -D 文章图片 操作 【Hugo】markdown中图片大小和对齐方式调整\n脚本自动化 在vscode 我建立了一个工作区 写了一些个脚本 新建文章 删除文章 本地预览 更新远程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 { \u0026#34;folders\u0026#34;: [ { \u0026#34;path\u0026#34;: \u0026#34;..\u0026#34; } ], \u0026#34;settings\u0026#34;: { \u0026#34;VsCodeTaskButtons.tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;$(zap)New\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;New\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;创建一个新文章\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;$(notebook-delete-cell) Clean\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;clean\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;删除指定文章\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;$(globe)localview\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;localview\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;本地预览\u0026#34; }, ] }, \u0026#34;tasks\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;New\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;./hugo.exe new content post/${input:Blogname}/index.md\u0026#34;, }, { \u0026#34;label\u0026#34;: \u0026#34;clean\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;Remove-Item -Recurse -Force -Path ${workspaceFolder}\\\\content\\\\post\\\\${input:cleanBlogname}\u0026#34;, }, { \u0026#34;label\u0026#34;: \u0026#34;localview\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;./hugo.exe server -D\u0026#34;, }, ], \u0026#34;inputs\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Blogname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;输入文章名字\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;Blogname\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;cleanBlogname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;输入需要删除文章名字\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;cleanBlogname\u0026#34; }, ] } } 在 VSCode 的 tasks.json 文件中，$(zap) 是一个图标名称，用于在任务列表中显示一个图标。这些图标名称是 VSCode 的内置图标，用于在用户界面中提供视觉提示。\nVSCode 的图标名称是基于 Octicons 图标集的。Octicons 是 GitHub 的官方图标集，广泛用于 VSCode 的界面中。以下是一些常用的图标名称示例：\n$(zap) - 闪电图标，通常用于表示快速或强大的操作. $(gear) - 齿轮图标，通常用于设置或配置相关的操作. $(file) - 文件图标，用于表示文件相关的操作. $(trash) - 垃圾桶图标，用于表示删除或清理相关的操作. 你可以在 VSCode 的任务配置中使用这些图标名称来为任务添加视觉效果，使任务列表更加直观和易于理解.\n如果你需要查找更多的图标名称，可以参考 Octicons 的官方文档，其中列出了所有可用的图标及其名称.\n外链图片图床 不搞感觉会炸\n参考链接1\n参考链接2 参考连接3\n1 2 3 4 如果加速源无法使用可以更改加速源，将github的设定自定义域名处的cdn.jsdmirror.com改为其他加速源 jsd.onmicrosoft.cn gcore.jsdelivr.net testingcf.jsdelivr.net 下面这张图是图床上的 还有一些链接建立网站时候用的 https://www.hughh.top/posts/hugo-guide/\n","date":"2025-02-18T11:13:00+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145323127.png","permalink":"https://clingyang.github.io/p/hugo%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E%E8%AE%B0%E8%BD%BD%E7%AC%94%E8%AE%B0/","title":"hugo格式说明记载笔记"},{"content":"环境搭建 环境搭建后第一段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; void taskA(void *pvParameter) { while (1) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Task 1\u0026#34;); vTaskDelay(pdMS_TO_TICKS(500)); } } void app_main(void) { // tskNO_AFFINITY 双核都可以运行 xTaskCreatePinnedToCore(taskA, \u0026#34;taskA\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); } main 是特殊的组件\n任务同步 队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;freertos/queue.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; QueueHandle_t Queue_handle = NULL; typedef struct { int a; int b; } QueueMessage_t; void taksA(void *pvParameter) { QueueMessage_t message; message.a = 1; message.b = 2; while (1) { if (xQueueSend(Queue_handle, \u0026amp;message, 0) == pdTRUE) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Send success\u0026#34;); } else { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Send failed\u0026#34;); } message.a++; message.b++; vTaskDelay(pdMS_TO_TICKS(500)); } } void taksB(void *pvParameter) { QueueMessage_t message; while (1) { if (pdTRUE == xQueueReceive(Queue_handle, \u0026amp;message, 0)) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Receive success\u0026#34;); ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;a=%d, b=%d\u0026#34;, message.a, message.b); } else { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Receive failed\u0026#34;); } vTaskDelay(pdMS_TO_TICKS(500)); } } void app_main(void) { Queue_handle = xQueueCreate(10, sizeof(QueueMessage_t)); if (NULL == Queue_handle ) { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Queue create failed\u0026#34;); } else { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Queue create success\u0026#34;); } xTaskCreatePinnedToCore(taksA, \u0026#34;taksA\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); xTaskCreatePinnedToCore(taksB, \u0026#34;taksB\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); } 信号量 任务保护硬件机制 事件组 直达任务通知 原生区别 GPIO 操作 环境搭建 乐鑫官方文章 text text ","date":"2025-01-08T23:58:10+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320145836481.png","permalink":"https://clingyang.github.io/p/esp_note/","title":"ESP_Note"},{"content":" 主要利用的是vscode里面stm32forvscode的插件 第一步就是创建cubmax的工程 RCC 调试方式 和 时基 这里Debug 不整好 这个板子就会变砖 要用线刷了\n选择FREERTOS\n选择最大频率 .c 和 .h 文件分开生成 生成！！(原神启动) 关于这个框架的建立 我选择如下这样 应用和驱动：\n你新建了两个文件夹所以需要再makefile文件添加进来\n这个插件可以帮你添加但是需要你设置一下\nDrivers 层面 .c 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026#34;led_driver.h\u0026#34; /// @brief 全彩灯初始化 /// @param void led_init(void) { HAL_GPIO_WritePin(RGB_PORT_R, RGB_PIN_R, GPIO_PIN_SET); HAL_GPIO_WritePin(RGB_PORT_G, RGB_PIN_G, GPIO_PIN_SET); HAL_GPIO_WritePin(RGB_PORT_B, RGB_PIN_B, GPIO_PIN_SET); } /// @brief 设置灯的颜色 /// @param red /// @param green /// @param blue void color_led_set(uint8_t red, uint8_t green, uint8_t blue) { //红灯： HAL_GPIO_WritePin(RGB_PORT_R, RGB_PIN_R, (GPIO_PinState)!red); //绿灯： HAL_GPIO_WritePin(RGB_PORT_G, RGB_PIN_G, (GPIO_PinState)!green); //蓝灯： HAL_GPIO_WritePin(RGB_PORT_B, RGB_PIN_B, (GPIO_PinState)!blue); } .h文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #ifndef __LED_DRIVER_H__ #define __LED_DRIVER_H__ #include \u0026#34;main.h\u0026#34; #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif #define RGB_PORT_R GPIOB #define RGB_PORT_G GPIOB #define RGB_PORT_B GPIOB #define RGB_PIN_R GPIO_PIN_5 #define RGB_PIN_G GPIO_PIN_0 #define RGB_PIN_B GPIO_PIN_1 void color_led_set(uint8_t red, uint8_t green, uint8_t blue); void led_init(void); #ifdef __cplusplus } #endif #endif /* __LED_DRIVER_H__ */ app应用层面 .h 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #ifndef MAIN_INCLUDE_APPLICATION_H_ #define MAIN_INCLUDE_APPLICATION_H_ #ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif /*Driver Include*/ #include \u0026#34;led_driver.h\u0026#34; #include \u0026#34;beep_driver.h\u0026#34; #include \u0026#34;my_printf.h\u0026#34; /*User lib Include*/ /*pnblic Include*/ #include \u0026#34;FreeRTOS.h\u0026#34; #include \u0026#34;task.h\u0026#34; #include \u0026#34;main.h\u0026#34; #include \u0026#34;cmsis_os.h\u0026#34; #include \u0026lt;stdio.h\u0026gt; // sprintf #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; /********************************************************API********************************************************/ void AppTaskCreate(void); /*LED app*/ void color_led_task_fun(void *argument); /* 测试任务 */ void test_task_fun(void *arg); #ifdef __cplusplus } #endif #endif /* MAIN_INCLUDE_APPLICATION_H_ */ .c 创建任务函数文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include \u0026#34;Application.h\u0026#34; /**************************** 任务句柄 ********************************/ /* * 任务句柄是一个指针，用于指向一个任务，当任务创建好之后，它就具有了一个任务句柄 * 以后我们要想操作这个任务都需要通过这个任务句柄，如果是自身的任务操作自己，那么 * 这个句柄可以为NULL。 */ static TaskHandle_t COLOR_LED_Handle = NULL; /* LED任务句柄 */ static TaskHandle_t TEST_TASK_Handle = NULL; /* 任务句柄 */ /********************************** 内核对象句柄 *********************************/ /* * 信号量，消息队列，事件标志组，软件定时器这些都属于内核的对象，要想使用这些内核 * 对象，必须先创建，创建成功之后会返回一个相应的句柄。实际上就是一个指针，后续我 * 们就可以通过这个句柄操作这些内核对象。 * * 内核对象说白了就是一种全局的数据结构，通过这些数据结构我们可以实现任务间的通信， * 任务间的事件同步等各种功能。至于这些功能的实现我们是通过调用这些内核对象的函数 * 来完成的 * */ /******************************* 全局变量声明 ************************************/ /* * 当我们在写应用程序的时候，可能需要用到一些全局变量。 */ /* ************************************************************************* * 函数声明 ************************************************************************* */ void app_main_delay_ms(uint16_t ms); /* ************************************************************************* ************************************************************************* */ /// @brief 创建任务 /// @param void AppTaskCreate(void) { taskENTER_CRITICAL(); // 进入临界区 BaseType_t xReturn = pdPASS; /* 定义一个创建信息返回值，默认为pdPASS */ uint32_t count = 0; /* 创建Test_Task任务 */ xReturn = xTaskCreate((TaskFunction_t)color_led_task_fun, /* 任务入口函数 */ (const char *)\u0026#34;COLOR_LED_TASK\u0026#34;, /* 任务名字 */ (uint16_t)256, /* 任务栈大小 */ (void *)NULL, /* 任务入口函数参数 */ (UBaseType_t)osPriorityNormal, /* 任务的优先级 */ (TaskHandle_t *)\u0026amp;COLOR_LED_Handle); /* 任务控制块指针 */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;COLOR_LED_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); xReturn = xTaskCreate((TaskFunction_t)test_task_fun, /* 任务入口函数 */ (const char *)\u0026#34;TEST_TASK\u0026#34;, /* 任务名字 */ (uint16_t)256, /* 任务栈大小 */ (void *)NULL, /* 任务入口函数参数 */ (UBaseType_t)osPriorityNormal, /* 任务的优先级 */ (TaskHandle_t *)\u0026amp;TEST_TASK_Handle); /* 任务控制块指针 */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;TEST_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); return; error: UART1_Printf(\u0026#34;App_Task_Create[error]:Task Create fail,system exception\\n\u0026#34;); while (1) { UART1_Printf(\u0026#34;error count:%d\\n\u0026#34;, (int)count++); app_main_delay_ms(1000); } taskEXIT_CRITICAL(); // 退出临界区 } void app_main_delay_ms(uint16_t ms) { vTaskDelay(pdMS_TO_TICKS(ms)); } .c 任务分离文件\n关于如何应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \u0026#34;Application.h\u0026#34; /// @brief color_led_task_fun RGB 灯的应用 /// @param arg void color_led_task_fun(void *arg) { while (true) { /* color_led的应用 */ //红灯亮： color_led_set(1, 0, 0); os_Delay(1000); //绿灯亮： color_led_set(0, 1, 0); os_Delay(1000); //蓝灯亮： color_led_set(0, 0, 1); os_Delay(1000); //黄灯亮： color_led_set(1, 1, 0); os_Delay(1000); //紫灯亮： color_led_set(1, 0, 1); os_Delay(1000); //粉灯亮 color_led_set(0, 1, 1); os_Delay(1000); } } 关于如何嵌入框架 你只需要以下两步就行 第二步 ","date":"2024-11-20T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320151456223.png","permalink":"https://clingyang.github.io/p/hal_freertos%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%951/","title":"HAL_Freertos的使用记录1"},{"content":"往期内容导航 第一步准备环境 STM32CubeMX VSCODE MinGW OpenOcd arm-none-eabi-gcc 然后把上面下载的软件 3 4 5 bin 文件目录添加到系统变量\nvscode 插件插件配置 1. 下载这个插件 stm32-for-vscode 配置3 4 5 的 文件地址\n新建一个cubemx的工程 双击后来到这里 配置引脚 PC13 putout 设置生成选项 点灯 写入反转 在 /* USER CODE BEGIN 3 */和 /* USER CODE END 3 */ 之间 如图所示：\nbuild 和 flsah build flash ","date":"2024-11-20T14:25:54+08:00","image":"https://cdn.jsdelivr.net/gh/ClingYang/img1@latest/20250320175246956.png","permalink":"https://clingyang.github.io/p/stm32cubemx-vscode-gcc-makefile-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"stm32cubemx+VSCODE+GCC+makefile 开发环境搭建"}]