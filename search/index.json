[{"content":"关于主任务函数 之前写到在主函数里面处理的事件也不知道有没有问题 之所以这么写是因为我觉得如果全用cubemax配置好的话下次如果换主控可能会比较麻烦 所以今天再细看一下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void AppTaskCreate(void) { taskENTER_CRITICAL(); // 进入临界区 BaseType_t xReturn = pdPASS; /* 定义一个创建信息返回值，默认为pdPASS */ uint32_t count = 0; /* 创建Test_Task任务 */ xReturn = xTaskCreate((TaskFunction_t)color_led_task_fun, /* 任务入口函数 */ (const char *)\u0026#34;COLOR_LED_TASK\u0026#34;, /* 任务名字 */ (uint16_t)256, /* 任务栈大小 */ (void *)NULL, /* 任务入口函数参数 */ (UBaseType_t)osPriorityNormal, /* 任务的优先级 */ (TaskHandle_t *)\u0026amp;COLOR_LED_Handle); /* 任务控制块指针 */ if (pdPASS != xReturn) { goto error; } UART1_Printf(\u0026#34;COLOR_LED_TASK[info]:Runing, Priority:%d\\n\u0026#34;, osPriorityNormal); /* 运行占用 */ memset(pcWriteBuffer, 0, 400); vTaskList(pcWriteBuffer); // 获取内存信息 UART1_Printf(\u0026#34;\\r\\n\u0026#34;); UART1_Printf(\u0026#34;%s\\n\\r\u0026#34;, pcWriteBuffer); memset(pcWriteBuffer, 0, 400); vTaskGetRunTimeStats(pcWriteBuffer); // 获取CPU占用率信息 UART1_Printf(\u0026#34;\\r\\n\u0026#34;); UART1_Printf(\u0026#34;%s\\n\\r\u0026#34;, pcWriteBuffer); return; error: UART1_Printf(\u0026#34;App_Task_Create[error]:Task Create fail,system exception\\n\u0026#34;); while (1) { UART1_Printf(\u0026#34;error count:%d\\n\u0026#34;, (int)count++); app_main_delay_ms(1000); } taskEXIT_CRITICAL(); // 退出临界区 } 又添加了一些功能\n串口就会打印出这样的内容 当然在这之前还是要在cubemax里面打开一些东西 参考链接 全部打开变成Enable 每次配置任务就可以这样进行 修改如下 当然应用函数还是得要你自己写的 这样好处我感觉就是到时候你要是迁移芯片修改的应该不是很大\n","date":"2025-03-20T14:25:54+08:00","permalink":"https://clingyang.github.io/p/hal_freertos%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%952/","title":"HAL_Freertos的使用记录2"},{"content":"为了保存工作状态 长按关机后或者30分钟后断电 在这个操作前先保存状态 下次开机时直接读取保存内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026#34;Flash_baup.h\u0026#34; void SaveStateToFlash(uint8_t level, uint8_t reverse) { // 解锁 Flash HAL_FLASH_Unlock(); // 擦除 Flash 页 FLASH_EraseInitTypeDef EraseInitStruct; uint32_t PageError = 0; EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; EraseInitStruct.PageAddress = FLASH_USER_START_ADDR; EraseInitStruct.NbPages = 1; if (HAL_FLASHEx_Erase(\u0026amp;EraseInitStruct, \u0026amp;PageError) != HAL_OK) { // 错误处理 Error_Handler(); } // 写入当前档位和正反转状态 uint32_t data = (level \u0026lt;\u0026lt; 8) | reverse; if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, FLASH_USER_START_ADDR, data) != HAL_OK) { // 错误处理 Error_Handler(); } // 锁定 Flash HAL_FLASH_Lock(); } void LoadStateFromFlash(uint8_t *level, uint8_t *reverse) { uint32_t data = *(__IO uint32_t*)FLASH_USER_START_ADDR; *level = (data \u0026gt;\u0026gt; 8) \u0026amp; 0xFF; *reverse = data \u0026amp; 0xFF; } 头文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #ifndef FLASH_BAUP_H #define FLASH_BAUP_H #include \u0026#34;stm32f0xx_hal.h\u0026#34; #include \u0026#34;main.h\u0026#34; // 定义 Flash 存储地址 #define FLASH_USER_START_ADDR ((uint32_t)0x08007000) /* Start @ of user Flash area, assuming 1KB per page and 128KB total Flash size */ // Flash 操作函数声明 void SaveStateToFlash(uint8_t level, uint8_t reverse); void LoadStateFromFlash(uint8_t *level, uint8_t *reverse); #endif // FLASH_BAUP_H 保存的是两个 uint8_t 的数据 值得注意的是我们要注意地址 存储的起始地址有讲究的 最后通过keil 也是能看到的 如果资源紧张 可以debug 一下 ","date":"2025-03-20T11:46:54+08:00","permalink":"https://clingyang.github.io/p/hal_flash-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%AF%BB%E5%8F%96/","title":"HAL_flash 数据备份与读取"},{"content":"","date":"2025-03-20T11:08:09+08:00","image":"https://picsum.photos/800/600.webp?random=64c1c985","permalink":"https://clingyang.github.io/p/esp32-arduino-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"ESP32 ARDUINO 开发环境搭建"},{"content":"文章默认格式模版 推荐在模板中设置，修改 archetypes/default.md（如果没有则新建一个即可）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 --- date : \u0026#39;{{ .Date }}\u0026#39; draft: true title: \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; image: https://picsum.photos/800/600.webp?random={{ substr (md5 (.Date)) 4 8 }} description: 描述 summary: 文章摘要，重要！关乎ESO搜索引擎优化 categories: [ \u0026#34;hugo\u0026#34;, \u0026#34;笔记\u0026#34;, ] tags: [ \u0026#34;hugo\u0026#34;, \u0026#34;笔记\u0026#34; ] --- 这里的重点是 image 这一行，即使用了 Lorem Picsum 的接口，然后就可以得到一张随机的图片，更多详情也可前往 Lorem Picsum 了解。 之后，我们通过 hugo new 命令时，新建的文章会随机匹配一张图片\n文章的一写变量的写法 说明tags 一般是在文章内部的标题 我还要修改图片粘贴路径 在vscode 设置里面 评论区我成了 参考链接 效果可以看我评论区\n1 2 3 4 #创建新的笔记是 .\\hugo new content post/Blogname/index.md # 本地调试启动服务 .\\hugo server -D 文章图片 操作 【Hugo】markdown中图片大小和对齐方式调整\n脚本自动化 在vscode 我建立了一个工作区 写了一些个脚本 新建文章 删除文章 本地预览 更新远程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 { \u0026#34;folders\u0026#34;: [ { \u0026#34;path\u0026#34;: \u0026#34;..\u0026#34; } ], \u0026#34;settings\u0026#34;: { \u0026#34;VsCodeTaskButtons.tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;$(zap)New\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;New\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;创建一个新文章\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;$(notebook-delete-cell) Clean\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;clean\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;删除指定文章\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;$(globe)localview\u0026#34;, \u0026#34;task\u0026#34;: \u0026#34;localview\u0026#34;, \u0026#34;tooltip\u0026#34;: \u0026#34;本地预览\u0026#34; }, ] }, \u0026#34;tasks\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;New\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;./hugo.exe new content post/${input:Blogname}/index.md\u0026#34;, }, { \u0026#34;label\u0026#34;: \u0026#34;clean\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;Remove-Item -Recurse -Force -Path ${workspaceFolder}\\\\content\\\\post\\\\${input:cleanBlogname}\u0026#34;, }, { \u0026#34;label\u0026#34;: \u0026#34;localview\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;./hugo.exe server -D\u0026#34;, }, ], \u0026#34;inputs\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Blogname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;输入文章名字\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;Blogname\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;cleanBlogname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;promptString\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;输入需要删除文章名字\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;cleanBlogname\u0026#34; }, ] } } 在 VSCode 的 tasks.json 文件中，$(zap) 是一个图标名称，用于在任务列表中显示一个图标。这些图标名称是 VSCode 的内置图标，用于在用户界面中提供视觉提示。\nVSCode 的图标名称是基于 Octicons 图标集的。Octicons 是 GitHub 的官方图标集，广泛用于 VSCode 的界面中。以下是一些常用的图标名称示例：\n$(zap) - 闪电图标，通常用于表示快速或强大的操作. $(gear) - 齿轮图标，通常用于设置或配置相关的操作. $(file) - 文件图标，用于表示文件相关的操作. $(trash) - 垃圾桶图标，用于表示删除或清理相关的操作. 你可以在 VSCode 的任务配置中使用这些图标名称来为任务添加视觉效果，使任务列表更加直观和易于理解.\n如果你需要查找更多的图标名称，可以参考 Octicons 的官方文档，其中列出了所有可用的图标及其名称.\n外链图片图床 不搞感觉会炸\n参考链接1\n参考链接2 参考连接3\n1 2 3 4 如果加速源无法使用可以更改加速源，将github的设定自定义域名处的cdn.jsdmirror.com改为其他加速源 jsd.onmicrosoft.cn gcore.jsdelivr.net testingcf.jsdelivr.net 下面这张图是图床上的 还有一些链接建立网站时候用的 https://www.hughh.top/posts/hugo-guide/\n","date":"2025-02-18T11:13:00+08:00","image":"https://picsum.photos/800/600.webp?random=c8411847","permalink":"https://clingyang.github.io/p/test/","title":"test"},{"content":"环境搭建 环境搭建后第一段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; void taskA(void *pvParameter) { while (1) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Task 1\u0026#34;); vTaskDelay(pdMS_TO_TICKS(500)); } } void app_main(void) { // tskNO_AFFINITY 双核都可以运行 xTaskCreatePinnedToCore(taskA, \u0026#34;taskA\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); } main 是特殊的组件\n任务同步 队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;freertos/FreeRTOS.h\u0026#34; #include \u0026#34;freertos/task.h\u0026#34; #include \u0026#34;freertos/queue.h\u0026#34; #include \u0026#34;esp_log.h\u0026#34; QueueHandle_t Queue_handle = NULL; typedef struct { int a; int b; } QueueMessage_t; void taksA(void *pvParameter) { QueueMessage_t message; message.a = 1; message.b = 2; while (1) { if (xQueueSend(Queue_handle, \u0026amp;message, 0) == pdTRUE) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Send success\u0026#34;); } else { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Send failed\u0026#34;); } message.a++; message.b++; vTaskDelay(pdMS_TO_TICKS(500)); } } void taksB(void *pvParameter) { QueueMessage_t message; while (1) { if (pdTRUE == xQueueReceive(Queue_handle, \u0026amp;message, 0)) { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Receive success\u0026#34;); ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;a=%d, b=%d\u0026#34;, message.a, message.b); } else { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Receive failed\u0026#34;); } vTaskDelay(pdMS_TO_TICKS(500)); } } void app_main(void) { Queue_handle = xQueueCreate(10, sizeof(QueueMessage_t)); if (NULL == Queue_handle ) { ESP_LOGE(\u0026#34;main\u0026#34;, \u0026#34;Queue create failed\u0026#34;); } else { ESP_LOGI(\u0026#34;main\u0026#34;, \u0026#34;Queue create success\u0026#34;); } xTaskCreatePinnedToCore(taksA, \u0026#34;taksA\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); xTaskCreatePinnedToCore(taksB, \u0026#34;taksB\u0026#34;, 2048, NULL, 3, NULL, tskNO_AFFINITY); } 信号量 任务保护硬件机制 事件组 直达任务通知 原生区别 GPIO 操作 环境搭建 乐鑫官方文章 text text ","date":"2025-01-08T23:58:10+08:00","image":"https://picsum.photos/800/600.webp?random=aa63e533","permalink":"https://clingyang.github.io/p/esp_note/","title":"ESP_Note"}]