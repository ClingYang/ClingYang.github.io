<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic JSON Oscilloscope</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #0a0a0f;
            color: #00ff88;
            font-family: 'Segoe UI', monospace;
            overflow: hidden;
            height: 100vh;
            user-select: none;
        }
        
        .container {
            display: grid;
            grid-template-columns: 280px 1fr 240px;
            height: 100vh;
            gap: 1px;
            background: #000;
        }
        
        .control-panel {
            background: #111118;
            padding: 12px;
            border-right: 1px solid #222;
            overflow-y: auto;
            font-size: 11px;
        }
        
        .measure-panel {
            background: #111118;
            padding: 12px;
            border-left: 1px solid #222;
            overflow-y: auto;
            font-size: 11px;
        }
        
        .panel-title {
            font-size: 10px;
            font-weight: bold;
            margin: 15px 0 8px 0;
            color: #00ff88;
            border-bottom: 1px solid #333;
            padding-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            background: #16161d;
            border: 1px solid #00ff88;
            color: #00ff88;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            border-radius: 3px;
            transition: all 0.2s;
            font-size: 10px;
        }
        
        .btn:hover { background: #00ff88; color: #000; }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .btn.danger { border-color: #ff4444; color: #ff4444; }
        .btn.danger:hover { background: #ff4444; color: #fff; }
        .btn.active { background: #ffaa44; border-color: #ffaa44; color: #000; }
        
        select, input[type="range"], input[type="number"] {
            width: 100%;
            padding: 5px;
            background: #0a0a0f;
            border: 1px solid #333;
            color: #fff;
            font-family: inherit;
            margin-bottom: 6px;
            border-radius: 3px;
            font-size: 11px;
        }
        
        input[type="number"] { 
            width: 60px; 
            text-align: right; 
            display: inline-block;
            margin-left: 8px;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            height: 2px;
            background: #2a2a30;
            width: calc(100% - 70px);
            vertical-align: middle;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: #00ff88;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            accent-color: #00ff88;
            cursor: pointer;
            width: 14px;
            height: 14px;
        }
        
        .channel-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid #2a2a30;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 8px;
            border-left: 3px solid;
            transition: all 0.3s;
        }
        
        .channel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .channel-name { 
            font-weight: bold; 
            font-size: 13px; 
            letter-spacing: 0.5px;
        }
        
        .channel-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 6px;
            gap: 8px;
        }
        
        .channel-label { 
            font-size: 10px; 
            color: #666; 
            min-width: 40px;
        }
        
        .auto-scale-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
            font-size: 10px;
            color: #888;
        }
        
        .empty-state {
            color: #444;
            text-align: center;
            padding: 30px 20px;
            font-style: italic;
            font-size: 11px;
            border: 1px dashed #222;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .stat-box {
            background: #0a0a0f;
            border: 1px solid #1f1f25;
            padding: 10px;
            margin-bottom: 6px;
            border-radius: 3px;
            border-left: 3px solid;
            transition: all 0.2s;
        }
        
        .stat-box:hover { background: #151518; }
        .stat-box.inactive { opacity: 0.3; }
        .stat-box.highlight { 
            background: rgba(255,255,255,0.05);
            border-color: #fff;
        }
        
        .stat-label {
            font-size: 10px;
            color: #555;
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        
        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #fff;
            font-family: monospace;
        }
        
        .display-area {
            position: relative;
            background: #000;
            display: flex;
            flex-direction: column;
        }
        
        .scope-header {
            height: 32px;
            background: #0f0f12;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            border-bottom: 1px solid #1a1a20;
            font-size: 10px;
            z-index: 10;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            display: inline-block;
            margin-right: 6px;
        }
        
        .status-dot.connected {
            background: #00ff88;
            box-shadow: 0 0 8px #00ff88;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
        
        #canvas { 
            flex: 1; 
            width: 100%; 
            cursor: crosshair;
            display: block;
        }
        
        .controls-overlay {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 50;
        }
        
        .control-btn {
            background: rgba(20,20,25,0.9);
            border: 1px solid #444;
            color: #888;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s;
            backdrop-filter: blur(4px);
        }
        
        .control-btn:hover {
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .control-btn.active {
            background: #ffaa44;
            border-color: #ffaa44;
            color: #000;
        }
        
        .pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,170,68,0.1);
            border: 1px solid #ffaa44;
            color: #ffaa44;
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            display: none;
            pointer-events: none;
            z-index: 20;
        }
        
        .hover-tooltip {
            position: absolute;
            background: rgba(0,0,0,0.95);
            border: 1px solid #555;
            border-left: 3px solid;
            border-radius: 4px;
            padding: 8px 12px;
            pointer-events: none;
            font-size: 12px;
            color: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.8);
            z-index: 100;
            display: none;
            min-width: 140px;
            backdrop-filter: blur(4px);
        }
        
        .hover-ch-name { font-weight: bold; margin-bottom: 4px; font-size: 13px; }
        .hover-value { font-family: monospace; font-size: 16px; margin: 4px 0; }
        .hover-time { color: #666; font-size: 9px; border-top: 1px solid #333; margin-top: 6px; padding-top: 4px; }
        
        @media (max-width: 1000px) {
            .container { grid-template-columns: 260px 1fr; }
            .measure-panel { display: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <div class="panel-title">Connection</div>
            <button id="connectBtn" class="btn">Connect Port</button>
            <button id="disconnectBtn" class="btn danger" disabled>Disconnect</button>
            
            <select id="baudRate" style="margin-top:8px">
                <option value="9600">9600</option>
                <option value="115200" selected>115200</option>
                <option value="921600">921600</option>
            </select>
            
            <div class="panel-title">Time Base</div>
            <select id="timePerDiv">
                <option value="10">10 μs/div</option>
                <option value="20">20 μs/div</option>
                <option value="50">50 μs/div</option>
                <option value="100">100 μs/div</option>
                <option value="200">200 μs/div</option>
                <option value="500">500 μs/div</option>
                <option value="1000">1 ms/div</option>
                <option value="2000">2 ms/div</option>
                <option value="5000">5 ms/div</option>
                <option value="10000" selected>10 ms/div</option>
                <option value="20000">20 ms/div</option>
                <option value="50000">50 ms/div</option>
                <option value="100000">100 ms/div</option>
                <option value="200000">200 ms/div</option>
                <option value="500000">500 ms/div</option>
                <option value="1000000">1 s/div</option>
                <option value="2000000">2 s/div</option>
                <option value="5000000">5 s/div</option>
            </select>
            
            <div class="panel-title">Buffer</div>
            <input type="range" id="bufferSize" min="100" max="2000" value="500" style="width:100%">
            <div style="text-align:right;color:#666;font-size:10px;margin-top:-5px">
                <span id="bufferDisplay">500</span> points
            </div>
            
            <div class="panel-title">Channels</div>
            <div id="channelsContainer">
                <div class="empty-state">Waiting for JSON data...</div>
            </div>
        </div>
        
        <div class="display-area">
            <div class="scope-header">
                <div>
                    <span class="status-dot" id="statusDot"></span>
                    <span id="statusText" style="color:#555">DISCONNECTED</span>
                </div>
                <div style="color:#333; font-size:10px; letter-spacing:1px">JSON OSCILLOSCOPE</div>
                <div style="color:#444">
                    <span id="chCount">0</span> CH | 
                    <span id="rxRate">0</span> B/s
                </div>
            </div>
            
            <canvas id="canvas"></canvas>
            
            <div class="pause-indicator" id="pauseIndicator">PAUSED</div>
            
            <div class="controls-overlay">
                <button id="pauseBtn" class="control-btn">PAUSE</button>
            </div>
            
            <div class="hover-tooltip" id="hoverTooltip">
                <div class="hover-ch-name" id="hoverName">Channel</div>
                <div class="hover-value" id="hoverValue">0.000</div>
                <div class="hover-time" id="hoverTime">T: 0.00ms</div>
            </div>
        </div>
        
        <div class="measure-panel">
            <div class="panel-title">Live Values</div>
            <div id="statsContainer">
                <div class="empty-state">No data</div>
            </div>
        </div>
    </div>

    <script>
        class JsonOscilloscope {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.port = null;
                this.reader = null;
                this.isConnected = false;
                this.textBuffer = '';
                
                this.channels = {};
                this.colors = [
                    '#00ff88', '#ff4477', '#4488ff', '#ffaa44', 
                    '#aa44ff', '#44ffff', '#ff44ff', '#ffff44',
                    '#ff6644', '#44ff66', '#6644ff', '#ffffff',
                    '#00ffff', '#ff00ff', '#88ff00', '#ff8800'
                ];
                this.colorIdx = 0;
                
                this.timePerDiv = 10000;
                this.maxPoints = 500;
                this.rxBytes = 0;
                this.lastRxTime = Date.now();
                
                this.isPaused = false;
                this.pauseTime = null;
                
                this.mouseX = -1;
                this.mouseY = -1;
                this.hoveredChannel = null;
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.setupEvents();
                this.animate();
            }
            
            resize() {
                this.canvas.width = this.canvas.offsetWidth;
                this.canvas.height = this.canvas.offsetHeight;
            }
            
            setupEvents() {
                document.getElementById('connectBtn').addEventListener('click', () => this.connect());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnect());
                
                document.getElementById('timePerDiv').addEventListener('change', e => {
                    this.timePerDiv = parseInt(e.target.value);
                });
                
                document.getElementById('bufferSize').addEventListener('input', e => {
                    this.maxPoints = parseInt(e.target.value);
                    document.getElementById('bufferDisplay').textContent = this.maxPoints;
                });
                
                document.getElementById('pauseBtn').addEventListener('click', (e) => {
                    this.isPaused = !this.isPaused;
                    e.target.textContent = this.isPaused ? 'RESUME' : 'PAUSE';
                    e.target.classList.toggle('active', this.isPaused);
                    document.getElementById('pauseIndicator').style.display = this.isPaused ? 'block' : 'none';
                    
                    if (this.isPaused) {
                        this.pauseTime = Date.now();
                    } else {
                        this.pauseTime = null;
                    }
                });
                
                this.canvas.addEventListener('mousemove', e => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.mouseY = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.mouseX = -1;
                    this.mouseY = -1;
                    this.hoveredChannel = null;
                    document.getElementById('hoverTooltip').style.display = 'none';
                    this.clearHighlight();
                });
            }
            
            async connect() {
                if (!('serial' in navigator)) {
                    alert('Use Chrome/Edge 89+');
                    return;
                }
                try {
                    this.port = await navigator.serial.requestPort();
                    await this.port.open({ baudRate: parseInt(document.getElementById('baudRate').value) });
                    this.isConnected = true;
                    this.updateUI();
                    this.readLoop();
                } catch(e) {
                    alert(e.message);
                }
            }
            
            async disconnect() {
                this.isConnected = false;
                if (this.reader) await this.reader.cancel();
                if (this.port) await this.port.close();
                this.port = null;
                this.updateUI();
            }
            
            async readLoop() {
                while (this.port?.readable && this.isConnected) {
                    try {
                        this.reader = this.port.readable.getReader();
                        while (true) {
                            const { value, done } = await this.reader.read();
                            if (done) break;
                            this.rxBytes += value.length;
                            this.processData(value);
                        }
                    } catch(e) {
                        console.error(e);
                        break;
                    } finally {
                        this.reader?.releaseLock();
                    }
                }
            }
            
            processData(uint8Array) {
                const text = new TextDecoder().decode(uint8Array);
                this.textBuffer += text;
                
                const { objects, remaining } = this.extractJsonObjects(this.textBuffer);
                objects.forEach(str => {
                    try {
                        const json = JSON.parse(str);
                        if (!this.isPaused) {
                            this.processJson(json);
                        }
                    } catch(e) {}
                });
                
                this.textBuffer = remaining;
                if (this.textBuffer.length > 4096) this.textBuffer = '';
            }
            
            extractJsonObjects(text) {
                const objects = [];
                let depth = 0, start = -1;
                
                for (let i = 0; i < text.length; i++) {
                    if (text[i] === '{') {
                        if (depth === 0) start = i;
                        depth++;
                    } else if (text[i] === '}') {
                        depth--;
                        if (depth === 0 && start !== -1) {
                            objects.push(text.substring(start, i + 1));
                            start = -1;
                        }
                    }
                }
                return { objects, remaining: (depth > 0 && start !== -1) ? text.substring(start) : '' };
            }
            
            processJson(json) {
                const timestamp = Date.now();
                // 修复：检查是否首次创建通道
                const isFirstChannel = Object.keys(this.channels).length === 0;
                
                Object.keys(json).forEach(key => {
                    const value = json[key];
                    if (typeof value !== 'number') return;
                    
                    if (!this.channels[key]) {
                        // 修复：首次创建时清空提示
                        if (isFirstChannel) {
                            document.getElementById('channelsContainer').innerHTML = '';
                            document.getElementById('statsContainer').innerHTML = '';
                        }
                        this.addChannel(key);
                    }
                    
                    const ch = this.channels[key];
                    ch.data.push({ value, time: timestamp });
                    if (ch.data.length > this.maxPoints) ch.data.shift();
                    
                    ch.current = value;
                    if (ch.data.length > 0) {
                        const values = ch.data.map(d => d.value);
                        ch.min = Math.min(...values);
                        ch.max = Math.max(...values);
                        
                        // Auto Scale 占 2 格
                        if (ch.autoScale && ch.max !== ch.min) {
                            ch.scale = (ch.max - ch.min) / 2;
                            if (ch.scale === 0) ch.scale = 1;
                            
                            const scaleInput = document.querySelector(`input[data-ch="${key}"][data-type="scale"]`);
                            const scaleText = document.getElementById(`scale-txt-${key}`);
                            if (scaleInput) scaleInput.value = ch.scale.toFixed(3);
                            if (scaleText) scaleText.textContent = `Auto (${ch.scale.toFixed(2)}/div, 2grids)`;
                        }
                    }
                });
                
                this.updateStats();
                document.getElementById('chCount').textContent = Object.keys(this.channels).length;
            }
            
            addChannel(name) {
                const color = this.colors[this.colorIdx % this.colors.length];
                this.colorIdx++;
                
                this.channels[name] = {
                    name, data: [], color,
                    scale: 1, offset: 0, visible: true,
                    autoScale: true,
                    current: 0, min: 0, max: 0
                };
                
                this.createChannelUI(name);
                this.createStatsUI(name);
            }
            
            createChannelUI(name) {
                const ch = this.channels[name];
                const div = document.createElement('div');
                div.className = 'channel-item';
                div.id = `ch-${name}`;
                div.style.borderLeftColor = ch.color;
                
                div.innerHTML = `
                    <div class="channel-header">
                        <span class="channel-name" style="color:${ch.color}">${name}</span>
                        <input type="checkbox" checked onchange="scope.toggleChannel('${name}')" 
                               style="cursor:pointer;transform:scale(1.2)">
                    </div>
                    
                    <div class="auto-scale-row">
                        <input type="checkbox" id="auto-${name}" checked 
                               onchange="scope.toggleAutoScale('${name}')">
                        <label for="auto-${name}">Auto Scale (2 grids)</label>
                    </div>
                    
                    <div class="channel-row">
                        <span class="channel-label">Scale</span>
                        <input type="range" min="0.001" max="1000" step="0.001" value="1" 
                               data-ch="${name}" data-type="scale"
                               oninput="scope.setScale('${name}', this.value)" style="flex:1">
                    </div>
                    <div style="text-align:right;font-size:9px;color:#555;margin-bottom:6px" id="scale-txt-${name}">
                        Auto (waiting...)
                    </div>
                    
                    <div class="channel-row">
                        <span class="channel-label">Offset</span>
                        <input type="number" value="0" step="10" min="-500" max="500"
                               oninput="scope.setOffset('${name}', this.value)"
                               style="background:#0a0a0f;border:1px solid #333;color:#fff;padding:4px 8px;border-radius:3px;width:70px">
                        <span style="font-size:10px;color:#444">px</span>
                    </div>
                `;
                
                document.getElementById('channelsContainer').appendChild(div);
            }
            
            createStatsUI(name) {
                const ch = this.channels[name];
                const div = document.createElement('div');
                div.className = 'stat-box';
                div.id = `stat-${name}`;
                div.style.borderLeftColor = ch.color;
                
                div.innerHTML = `
                    <div class="stat-label">
                        <span style="color:${ch.color};font-weight:bold">${name}</span>
                        <span style="color:#444;font-size:9px;display:none" class="minmax">${ch.min.toFixed(1)}~${ch.max.toFixed(1)}</span>
                    </div>
                    <div class="stat-value" id="val-${name}" style="color:${ch.color}">0.000</div>
                `;
                
                div.addEventListener('mouseenter', () => this.highlightChannel(name));
                div.addEventListener('mouseleave', () => this.clearHighlight());
                
                document.getElementById('statsContainer').appendChild(div);
            }
            
            toggleChannel(name) {
                if (!this.channels[name]) return;
                this.channels[name].visible = !this.channels[name].visible;
                const stat = document.getElementById(`stat-${name}`);
                if (stat) stat.classList.toggle('inactive', !this.channels[name].visible);
                document.getElementById(`ch-${name}`).style.opacity = this.channels[name].visible ? '1' : '0.5';
            }
            
            toggleAutoScale(name) {
                if (!this.channels[name]) return;
                const ch = this.channels[name];
                ch.autoScale = !ch.autoScale;
                
                const scaleText = document.getElementById(`scale-txt-${name}`);
                
                if (ch.autoScale) {
                    if (scaleText) {
                        scaleText.textContent = ch.scale > 0 ? `Auto (${ch.scale.toFixed(2)}/div)` : 'Auto';
                        scaleText.style.color = '#00ff88';
                    }
                    if (ch.max !== ch.min) {
                        ch.scale = (ch.max - ch.min) / 2;
                        const scaleInput = document.querySelector(`input[data-ch="${name}"][data-type="scale"]`);
                        if (scaleInput) scaleInput.value = ch.scale.toFixed(3);
                        if (scaleText) scaleText.textContent = `Auto (${ch.scale.toFixed(2)}/div, 2grids)`;
                    }
                } else {
                    if (scaleText) {
                        scaleText.textContent = `Manual (${ch.scale.toFixed(2)}/div)`;
                        scaleText.style.color = '#888';
                    }
                }
            }
            
            setScale(name, value) {
                if (!this.channels[name]) return;
                const ch = this.channels[name];
                ch.scale = parseFloat(value);
                const txt = document.getElementById(`scale-txt-${name}`);
                if (txt) {
                    if (ch.autoScale) {
                        txt.textContent = `Auto (${ch.scale.toFixed(2)}/div)`;
                    } else {
                        txt.textContent = `Manual (${ch.scale.toFixed(2)}/div)`;
                    }
                }
            }
            
            setOffset(name, value) {
                if (this.channels[name]) this.channels[name].offset = parseInt(value);
            }
            
            highlightChannel(name) {
                Object.keys(this.channels).forEach(n => {
                    const el = document.getElementById(`stat-${n}`);
                    if (el) el.classList.toggle('highlight', n === name);
                });
            }
            
            clearHighlight() {
                Object.keys(this.channels).forEach(n => {
                    const el = document.getElementById(`stat-${n}`);
                    if (el) el.classList.remove('highlight');
                });
            }
            
            updateStats() {
                Object.keys(this.channels).forEach(name => {
                    const ch = this.channels[name];
                    const el = document.getElementById(`val-${name}`);
                    if (!el) return;
                    const v = ch.current;
                    let display = Math.abs(v) >= 100 ? v.toFixed(1) : 
                                 Math.abs(v) >= 1 ? v.toFixed(2) : 
                                 Math.abs(v) >= 0.01 ? v.toFixed(3) : v.toExponential(2);
                    el.textContent = display;
                });
            }
            
            updateUI() {
                const dot = document.getElementById('statusDot');
                const text = document.getElementById('statusText');
                const conn = document.getElementById('connectBtn');
                const disconn = document.getElementById('disconnectBtn');
                
                if (this.isConnected) {
                    dot.classList.add('connected');
                    text.textContent = 'CONNECTED';
                    text.style.color = '#00ff88';
                    conn.disabled = true;
                    disconn.disabled = false;
                } else {
                    dot.classList.remove('connected');
                    text.textContent = 'DISCONNECTED';
                    text.style.color = '#555';
                    conn.disabled = false;
                    disconn.disabled = true;
                }
            }
            
            drawGrid() {
                const w = this.canvas.width, h = this.canvas.height;
                this.ctx.strokeStyle = '#1a1a24';
                this.ctx.lineWidth = 1;
                
                for (let i = 0; i <= 10; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo((w/10)*i, 0);
                    this.ctx.lineTo((w/10)*i, h);
                    this.ctx.stroke();
                }
                for (let i = 0; i <= 8; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, (h/8)*i);
                    this.ctx.lineTo(w, (h/8)*i);
                    this.ctx.stroke();
                }
                
                this.ctx.strokeStyle = '#2a2a35';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(w/2, 0); this.ctx.lineTo(w/2, h);
                this.ctx.moveTo(0, h/2); this.ctx.lineTo(w, h/2);
                this.ctx.stroke();
            }
            
            drawTraces() {
                const w = this.canvas.width, h = this.canvas.height;
                const now = this.isPaused ? this.pauseTime : Date.now();
                const timeWindow = this.timePerDiv * 10;
                
                Object.keys(this.channels).forEach(name => {
                    const ch = this.channels[name];
                    if (!ch.visible || ch.data.length < 2) return;
                    
                    const scaleY = (h * 0.8) / (ch.scale * 8);
                    const centerY = h/2 + ch.offset;
                    
                    this.ctx.strokeStyle = ch.color;
                    this.ctx.lineWidth = name === this.hoveredChannel ? 3 : 2;
                    this.ctx.shadowBlur = name === this.hoveredChannel ? 12 : 8;
                    this.ctx.shadowColor = ch.color;
                    
                    this.ctx.beginPath();
                    let first = true;
                    
                    for (let i = 0; i < ch.data.length; i++) {
                        const p = ch.data[i];
                        const age = now - p.time;
                        const x = w - (age / timeWindow) * w;
                        
                        if (x < -10) continue;
                        const y = centerY - (p.value * scaleY);
                        
                        if (first || x > w + 10) {
                            this.ctx.moveTo(x, y);
                            first = false;
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                });
            }
            
            drawHover() {
                if (this.mouseX < 0 || Object.keys(this.channels).length === 0) {
                    this.hoveredChannel = null;
                    return;
                }
                
                const w = this.canvas.width, h = this.canvas.height;
                const now = this.isPaused ? this.pauseTime : Date.now();
                const timeWindow = this.timePerDiv * 10;
                const timeAtMouse = now - ((w - this.mouseX) / w) * timeWindow;
                
                let closestCh = null;
                let minDistance = 25;
                let closestValue = null;
                let closestY = 0;
                
                Object.keys(this.channels).forEach(name => {
                    const ch = this.channels[name];
                    if (!ch.visible) return;
                    
                    let valueAtX = null;
                    for (let i = 0; i < ch.data.length - 1; i++) {
                        const p1 = ch.data[i];
                        const p2 = ch.data[i+1];
                        if (p1.time <= timeAtMouse && p2.time >= timeAtMouse) {
                            const t = (timeAtMouse - p1.time) / (p2.time - p1.time);
                            valueAtX = p1.value + (p2.value - p1.value) * t;
                            break;
                        }
                    }
                    
                    if (valueAtX !== null && ch.data.length > 0) {
                        const scaleY = (h * 0.8) / (ch.scale * 8);
                        const centerY = h/2 + ch.offset;
                        const yAtX = centerY - (valueAtX * scaleY);
                        const distance = Math.abs(this.mouseY - yAtX);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestCh = ch;
                            closestValue = valueAtX;
                            closestY = yAtX;
                        }
                    }
                });
                
                const tooltip = document.getElementById('hoverTooltip');
                
                if (closestCh) {
                    this.hoveredChannel = closestCh.name;
                    this.highlightChannel(closestCh.name);
                    
                    tooltip.style.display = 'block';
                    tooltip.style.borderColor = closestCh.color;
                    tooltip.style.left = Math.min(this.mouseX + 15, w - 160) + 'px';
                    tooltip.style.top = Math.max(this.mouseY - 40, 10) + 'px';
                    
                    document.getElementById('hoverName').textContent = closestCh.name;
                    document.getElementById('hoverName').style.color = closestCh.color;
                    
                    let valStr = Math.abs(closestValue) >= 100 ? closestValue.toFixed(1) : 
                                Math.abs(closestValue) >= 1 ? closestValue.toFixed(2) : 
                                closestValue.toFixed(3);
                    document.getElementById('hoverValue').textContent = valStr;
                    
                    const relativeTime = ((timeAtMouse - now) / 1000).toFixed(2);
                    document.getElementById('hoverTime').textContent = `T: ${relativeTime}s`;
                    
                    this.ctx.strokeStyle = closestCh.color;
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([3, 3]);
                    this.ctx.globalAlpha = 0.6;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.mouseX, 0);
                    this.ctx.lineTo(this.mouseX, h);
                    this.ctx.moveTo(0, closestY);
                    this.ctx.lineTo(w, closestY);
                    this.ctx.stroke();
                    
                    this.ctx.globalAlpha = 1;
                    this.ctx.setLineDash([]);
                    
                } else {
                    this.hoveredChannel = null;
                    tooltip.style.display = 'none';
                    this.clearHighlight();
                }
            }
            
            animate() {
                this.ctx.fillStyle = '#000000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawGrid();
                this.drawTraces();
                this.drawHover();
                
                const now = Date.now();
                if (now - this.lastRxTime >= 1000) {
                    document.getElementById('rxRate').textContent = this.rxBytes;
                    this.rxBytes = 0;
                    this.lastRxTime = now;
                }
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        const scope = new JsonOscilloscope();
    </script>
</body>
</html>